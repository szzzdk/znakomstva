import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-CEQRFMJQ.js";

// node_modules/boolean/build/lib/boolean.js
var require_boolean = __commonJS({
  "node_modules/boolean/build/lib/boolean.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolean = void 0;
    var boolean = function(value) {
      switch (Object.prototype.toString.call(value)) {
        case "[object String]":
          return ["true", "t", "yes", "y", "on", "1"].includes(value.trim().toLowerCase());
        case "[object Number]":
          return value.valueOf() === 1;
        case "[object Boolean]":
          return value.valueOf();
        default:
          return false;
      }
    };
    exports.boolean = boolean;
  }
});

// node_modules/boolean/build/lib/isBooleanable.js
var require_isBooleanable = __commonJS({
  "node_modules/boolean/build/lib/isBooleanable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBooleanable = void 0;
    var isBooleanable = function(value) {
      switch (Object.prototype.toString.call(value)) {
        case "[object String]":
          return [
            "true",
            "t",
            "yes",
            "y",
            "on",
            "1",
            "false",
            "f",
            "no",
            "n",
            "off",
            "0"
          ].includes(value.trim().toLowerCase());
        case "[object Number]":
          return [0, 1].includes(value.valueOf());
        case "[object Boolean]":
          return true;
        default:
          return false;
      }
    };
    exports.isBooleanable = isBooleanable;
  }
});

// node_modules/boolean/build/lib/index.js
var require_lib = __commonJS({
  "node_modules/boolean/build/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBooleanable = exports.boolean = void 0;
    var boolean_1 = require_boolean();
    Object.defineProperty(exports, "boolean", { enumerable: true, get: function() {
      return boolean_1.boolean;
    } });
    var isBooleanable_1 = require_isBooleanable();
    Object.defineProperty(exports, "isBooleanable", { enumerable: true, get: function() {
      return isBooleanable_1.isBooleanable;
    } });
  }
});

// node_modules/fast-printf/dist/src/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/fast-printf/dist/src/tokenize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenize = void 0;
    var TokenRule = /(?:%(?<flag>([+0-]|-\+))?(?<width>\d+)?(?<position>\d+\$)?(?<precision>\.\d+)?(?<conversion>[%BCESb-iosux]))|(\\%)/g;
    var tokenize = (subject) => {
      let matchResult;
      const tokens = [];
      let argumentIndex = 0;
      let lastIndex = 0;
      let lastToken = null;
      while ((matchResult = TokenRule.exec(subject)) !== null) {
        if (matchResult.index > lastIndex) {
          lastToken = {
            literal: subject.slice(lastIndex, matchResult.index),
            type: "literal"
          };
          tokens.push(lastToken);
        }
        const match = matchResult[0];
        lastIndex = matchResult.index + match.length;
        if (match === "\\%" || match === "%%") {
          if (lastToken && lastToken.type === "literal") {
            lastToken.literal += "%";
          } else {
            lastToken = {
              literal: "%",
              type: "literal"
            };
            tokens.push(lastToken);
          }
        } else if (matchResult.groups) {
          lastToken = {
            conversion: matchResult.groups.conversion,
            flag: matchResult.groups.flag || null,
            placeholder: match,
            position: matchResult.groups.position ? Number.parseInt(matchResult.groups.position, 10) - 1 : argumentIndex++,
            precision: matchResult.groups.precision ? Number.parseInt(matchResult.groups.precision.slice(1), 10) : null,
            type: "placeholder",
            width: matchResult.groups.width ? Number.parseInt(matchResult.groups.width, 10) : null
          };
          tokens.push(lastToken);
        }
      }
      if (lastIndex <= subject.length - 1) {
        if (lastToken && lastToken.type === "literal") {
          lastToken.literal += subject.slice(lastIndex);
        } else {
          tokens.push({
            literal: subject.slice(lastIndex),
            type: "literal"
          });
        }
      }
      return tokens;
    };
    exports.tokenize = tokenize;
  }
});

// node_modules/fast-printf/dist/src/createPrintf.js
var require_createPrintf = __commonJS({
  "node_modules/fast-printf/dist/src/createPrintf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPrintf = void 0;
    var boolean_1 = require_lib();
    var tokenize_1 = require_tokenize();
    var formatDefaultUnboundExpression = (subject, token) => {
      return token.placeholder;
    };
    var createPrintf = (configuration) => {
      var _a;
      const padValue = (value, width, flag) => {
        if (flag === "-") {
          return value.padEnd(width, " ");
        } else if (flag === "-+") {
          return ((Number(value) >= 0 ? "+" : "") + value).padEnd(width, " ");
        } else if (flag === "+") {
          return ((Number(value) >= 0 ? "+" : "") + value).padStart(width, " ");
        } else if (flag === "0") {
          return value.padStart(width, "0");
        } else {
          return value.padStart(width, " ");
        }
      };
      const formatUnboundExpression = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.formatUnboundExpression) !== null && _a !== void 0 ? _a : formatDefaultUnboundExpression;
      const cache = {};
      return (subject, ...boundValues) => {
        let tokens = cache[subject];
        if (!tokens) {
          tokens = cache[subject] = tokenize_1.tokenize(subject);
        }
        let result = "";
        for (const token of tokens) {
          if (token.type === "literal") {
            result += token.literal;
          } else {
            let boundValue = boundValues[token.position];
            if (boundValue === void 0) {
              result += formatUnboundExpression(subject, token, boundValues);
            } else if (token.conversion === "b") {
              result += boolean_1.boolean(boundValue) ? "true" : "false";
            } else if (token.conversion === "B") {
              result += boolean_1.boolean(boundValue) ? "TRUE" : "FALSE";
            } else if (token.conversion === "c") {
              result += boundValue;
            } else if (token.conversion === "C") {
              result += String(boundValue).toUpperCase();
            } else if (token.conversion === "i" || token.conversion === "d") {
              boundValue = String(Math.trunc(boundValue));
              if (token.width !== null) {
                boundValue = padValue(boundValue, token.width, token.flag);
              }
              result += boundValue;
            } else if (token.conversion === "e") {
              result += Number(boundValue).toExponential();
            } else if (token.conversion === "E") {
              result += Number(boundValue).toExponential().toUpperCase();
            } else if (token.conversion === "f") {
              if (token.precision !== null) {
                boundValue = Number(boundValue).toFixed(token.precision);
              }
              if (token.width !== null) {
                boundValue = padValue(String(boundValue), token.width, token.flag);
              }
              result += boundValue;
            } else if (token.conversion === "o") {
              result += (Number.parseInt(String(boundValue), 10) >>> 0).toString(8);
            } else if (token.conversion === "s") {
              if (token.width !== null) {
                boundValue = padValue(String(boundValue), token.width, token.flag);
              }
              result += boundValue;
            } else if (token.conversion === "S") {
              if (token.width !== null) {
                boundValue = padValue(String(boundValue), token.width, token.flag);
              }
              result += String(boundValue).toUpperCase();
            } else if (token.conversion === "u") {
              result += Number.parseInt(String(boundValue), 10) >>> 0;
            } else if (token.conversion === "x") {
              boundValue = (Number.parseInt(String(boundValue), 10) >>> 0).toString(16);
              if (token.width !== null) {
                boundValue = padValue(String(boundValue), token.width, token.flag);
              }
              result += boundValue;
            } else {
              throw new Error("Unknown format specifier.");
            }
          }
        }
        return result;
      };
    };
    exports.createPrintf = createPrintf;
  }
});

// node_modules/fast-printf/dist/src/printf.js
var require_printf = __commonJS({
  "node_modules/fast-printf/dist/src/printf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.printf = exports.createPrintf = void 0;
    var createPrintf_1 = require_createPrintf();
    Object.defineProperty(exports, "createPrintf", { enumerable: true, get: function() {
      return createPrintf_1.createPrintf;
    } });
    exports.printf = createPrintf_1.createPrintf();
  }
});

// node_modules/i18n/package.json
var require_package = __commonJS({
  "node_modules/i18n/package.json"(exports, module) {
    module.exports = {
      name: "i18n",
      description: "lightweight translation module with dynamic json storage",
      version: "0.15.1",
      homepage: "http://github.com/mashpie/i18n-node",
      repository: {
        type: "git",
        url: "http://github.com/mashpie/i18n-node.git"
      },
      author: "Marcus Spiegel <marcus.spiegel@gmail.com>",
      funding: {
        url: "https://github.com/sponsors/mashpie"
      },
      main: "./index",
      files: [
        "i18n.js",
        "index.js",
        "SECURITY.md"
      ],
      keywords: [
        "template",
        "i18n",
        "l10n"
      ],
      directories: {
        lib: "."
      },
      dependencies: {
        "@messageformat/core": "^3.0.0",
        debug: "^4.3.3",
        "fast-printf": "^1.6.9",
        "make-plural": "^7.0.0",
        "math-interval-parser": "^2.0.1",
        mustache: "^4.2.0"
      },
      devDependencies: {
        async: "^3.2.3",
        "cookie-parser": "^1.4.6",
        eslint: "^8.8.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-config-standard": "^17.0.0",
        "eslint-plugin-import": "^2.25.4",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-prettier": "^4.0.0",
        "eslint-plugin-promise": "^6.0.0",
        "eslint-plugin-standard": "^5.0.0",
        express: "^4.17.2",
        husky: "^8.0.1",
        "lint-staged": "^12.3.2",
        mocha: "^10.0.0",
        nyc: "^15.1.0",
        prettier: "^2.5.1",
        should: "^13.2.3",
        sinon: "^14.0.0",
        yaml: "^2.1.0",
        zombie: "^6.1.4"
      },
      engines: {
        node: ">=10"
      },
      scripts: {
        test: "mocha --exit",
        "test-ci": "nyc mocha -- --exit",
        coverage: "nyc report --reporter=lcov"
      },
      "lint-staged": {
        "*.js": "eslint --cache --fix"
      },
      license: "MIT",
      husky: {
        hooks: {
          "pre-commit": "lint-staged"
        }
      }
    };
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d2 = h * 24;
    var w = d2 * 7;
    var y = d2 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return Math.round(ms2 / d2) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms2 / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms2 / s) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return plural(ms2, msAbs, d2, "day");
      }
      if (msAbs >= h) {
        return plural(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms2, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms2, msAbs, s, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/mustache/mustache.js
var require_mustache = __commonJS({
  "node_modules/mustache/mustache.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.Mustache = factory());
    })(exports, function() {
      "use strict";
      var objectToString = Object.prototype.toString;
      var isArray = Array.isArray || function isArrayPolyfill(object) {
        return objectToString.call(object) === "[object Array]";
      };
      function isFunction(object) {
        return typeof object === "function";
      }
      function typeStr(obj) {
        return isArray(obj) ? "array" : typeof obj;
      }
      function escapeRegExp(string) {
        return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      }
      function hasProperty(obj, propName) {
        return obj != null && typeof obj === "object" && propName in obj;
      }
      function primitiveHasOwnProperty(primitive, propName) {
        return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
      }
      var regExpTest = RegExp.prototype.test;
      function testRegExp(re, string) {
        return regExpTest.call(re, string);
      }
      var nonSpaceRe = /\S/;
      function isWhitespace(string) {
        return !testRegExp(nonSpaceRe, string);
      }
      var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      function escapeHtml(string) {
        return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
          return entityMap[s];
        });
      }
      var whiteRe = /\s*/;
      var spaceRe = /\s+/;
      var equalsRe = /\s*=/;
      var curlyRe = /\s*\}/;
      var tagRe = /#|\^|\/|>|\{|&|=|!/;
      function parseTemplate(template, tags) {
        if (!template)
          return [];
        var lineHasNonSpace = false;
        var sections = [];
        var tokens = [];
        var spaces = [];
        var hasTag = false;
        var nonSpace = false;
        var indentation = "";
        var tagIndex = 0;
        function stripSpace() {
          if (hasTag && !nonSpace) {
            while (spaces.length)
              delete tokens[spaces.pop()];
          } else {
            spaces = [];
          }
          hasTag = false;
          nonSpace = false;
        }
        var openingTagRe, closingTagRe, closingCurlyRe;
        function compileTags(tagsToCompile) {
          if (typeof tagsToCompile === "string")
            tagsToCompile = tagsToCompile.split(spaceRe, 2);
          if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
            throw new Error("Invalid tags: " + tagsToCompile);
          openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
          closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
          closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
        }
        compileTags(tags || mustache.tags);
        var scanner = new Scanner(template);
        var start, type, value, chr2, token, openSection;
        while (!scanner.eos()) {
          start = scanner.pos;
          value = scanner.scanUntil(openingTagRe);
          if (value) {
            for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
              chr2 = value.charAt(i);
              if (isWhitespace(chr2)) {
                spaces.push(tokens.length);
                indentation += chr2;
              } else {
                nonSpace = true;
                lineHasNonSpace = true;
                indentation += " ";
              }
              tokens.push(["text", chr2, start, start + 1]);
              start += 1;
              if (chr2 === "\n") {
                stripSpace();
                indentation = "";
                tagIndex = 0;
                lineHasNonSpace = false;
              }
            }
          }
          if (!scanner.scan(openingTagRe))
            break;
          hasTag = true;
          type = scanner.scan(tagRe) || "name";
          scanner.scan(whiteRe);
          if (type === "=") {
            value = scanner.scanUntil(equalsRe);
            scanner.scan(equalsRe);
            scanner.scanUntil(closingTagRe);
          } else if (type === "{") {
            value = scanner.scanUntil(closingCurlyRe);
            scanner.scan(curlyRe);
            scanner.scanUntil(closingTagRe);
            type = "&";
          } else {
            value = scanner.scanUntil(closingTagRe);
          }
          if (!scanner.scan(closingTagRe))
            throw new Error("Unclosed tag at " + scanner.pos);
          if (type == ">") {
            token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
          } else {
            token = [type, value, start, scanner.pos];
          }
          tagIndex++;
          tokens.push(token);
          if (type === "#" || type === "^") {
            sections.push(token);
          } else if (type === "/") {
            openSection = sections.pop();
            if (!openSection)
              throw new Error('Unopened section "' + value + '" at ' + start);
            if (openSection[1] !== value)
              throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
          } else if (type === "name" || type === "{" || type === "&") {
            nonSpace = true;
          } else if (type === "=") {
            compileTags(value);
          }
        }
        stripSpace();
        openSection = sections.pop();
        if (openSection)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
        return nestTokens(squashTokens(tokens));
      }
      function squashTokens(tokens) {
        var squashedTokens = [];
        var token, lastToken;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          if (token) {
            if (token[0] === "text" && lastToken && lastToken[0] === "text") {
              lastToken[1] += token[1];
              lastToken[3] = token[3];
            } else {
              squashedTokens.push(token);
              lastToken = token;
            }
          }
        }
        return squashedTokens;
      }
      function nestTokens(tokens) {
        var nestedTokens = [];
        var collector = nestedTokens;
        var sections = [];
        var token, section;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          switch (token[0]) {
            case "#":
            case "^":
              collector.push(token);
              sections.push(token);
              collector = token[4] = [];
              break;
            case "/":
              section = sections.pop();
              section[5] = token[2];
              collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
              break;
            default:
              collector.push(token);
          }
        }
        return nestedTokens;
      }
      function Scanner(string) {
        this.string = string;
        this.tail = string;
        this.pos = 0;
      }
      Scanner.prototype.eos = function eos() {
        return this.tail === "";
      };
      Scanner.prototype.scan = function scan(re) {
        var match = this.tail.match(re);
        if (!match || match.index !== 0)
          return "";
        var string = match[0];
        this.tail = this.tail.substring(string.length);
        this.pos += string.length;
        return string;
      };
      Scanner.prototype.scanUntil = function scanUntil(re) {
        var index = this.tail.search(re), match;
        switch (index) {
          case -1:
            match = this.tail;
            this.tail = "";
            break;
          case 0:
            match = "";
            break;
          default:
            match = this.tail.substring(0, index);
            this.tail = this.tail.substring(index);
        }
        this.pos += match.length;
        return match;
      };
      function Context(view, parentContext) {
        this.view = view;
        this.cache = { ".": this.view };
        this.parent = parentContext;
      }
      Context.prototype.push = function push(view) {
        return new Context(view, this);
      };
      Context.prototype.lookup = function lookup(name) {
        var cache = this.cache;
        var value;
        if (cache.hasOwnProperty(name)) {
          value = cache[name];
        } else {
          var context = this, intermediateValue, names, index, lookupHit = false;
          while (context) {
            if (name.indexOf(".") > 0) {
              intermediateValue = context.view;
              names = name.split(".");
              index = 0;
              while (intermediateValue != null && index < names.length) {
                if (index === names.length - 1)
                  lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
                intermediateValue = intermediateValue[names[index++]];
              }
            } else {
              intermediateValue = context.view[name];
              lookupHit = hasProperty(context.view, name);
            }
            if (lookupHit) {
              value = intermediateValue;
              break;
            }
            context = context.parent;
          }
          cache[name] = value;
        }
        if (isFunction(value))
          value = value.call(this.view);
        return value;
      };
      function Writer() {
        this.templateCache = {
          _cache: {},
          set: function set(key, value) {
            this._cache[key] = value;
          },
          get: function get(key) {
            return this._cache[key];
          },
          clear: function clear() {
            this._cache = {};
          }
        };
      }
      Writer.prototype.clearCache = function clearCache() {
        if (typeof this.templateCache !== "undefined") {
          this.templateCache.clear();
        }
      };
      Writer.prototype.parse = function parse(template, tags) {
        var cache = this.templateCache;
        var cacheKey = template + ":" + (tags || mustache.tags).join(":");
        var isCacheEnabled = typeof cache !== "undefined";
        var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
        if (tokens == void 0) {
          tokens = parseTemplate(template, tags);
          isCacheEnabled && cache.set(cacheKey, tokens);
        }
        return tokens;
      };
      Writer.prototype.render = function render(template, view, partials, config) {
        var tags = this.getConfigTags(config);
        var tokens = this.parse(template, tags);
        var context = view instanceof Context ? view : new Context(view, void 0);
        return this.renderTokens(tokens, context, partials, template, config);
      };
      Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
        var buffer = "";
        var token, symbol, value;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          value = void 0;
          token = tokens[i];
          symbol = token[0];
          if (symbol === "#")
            value = this.renderSection(token, context, partials, originalTemplate, config);
          else if (symbol === "^")
            value = this.renderInverted(token, context, partials, originalTemplate, config);
          else if (symbol === ">")
            value = this.renderPartial(token, context, partials, config);
          else if (symbol === "&")
            value = this.unescapedValue(token, context);
          else if (symbol === "name")
            value = this.escapedValue(token, context, config);
          else if (symbol === "text")
            value = this.rawValue(token);
          if (value !== void 0)
            buffer += value;
        }
        return buffer;
      };
      Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
        var self2 = this;
        var buffer = "";
        var value = context.lookup(token[1]);
        function subRender(template) {
          return self2.render(template, context, partials, config);
        }
        if (!value)
          return;
        if (isArray(value)) {
          for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
          }
        } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
          buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
        } else if (isFunction(value)) {
          if (typeof originalTemplate !== "string")
            throw new Error("Cannot use higher-order sections without the original template");
          value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
          if (value != null)
            buffer += value;
        } else {
          buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
        }
        return buffer;
      };
      Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
        var value = context.lookup(token[1]);
        if (!value || isArray(value) && value.length === 0)
          return this.renderTokens(token[4], context, partials, originalTemplate, config);
      };
      Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
        var filteredIndentation = indentation.replace(/[^ \t]/g, "");
        var partialByNl = partial.split("\n");
        for (var i = 0; i < partialByNl.length; i++) {
          if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
            partialByNl[i] = filteredIndentation + partialByNl[i];
          }
        }
        return partialByNl.join("\n");
      };
      Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
        if (!partials)
          return;
        var tags = this.getConfigTags(config);
        var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
        if (value != null) {
          var lineHasNonSpace = token[6];
          var tagIndex = token[5];
          var indentation = token[4];
          var indentedValue = value;
          if (tagIndex == 0 && indentation) {
            indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
          }
          var tokens = this.parse(indentedValue, tags);
          return this.renderTokens(tokens, context, partials, indentedValue, config);
        }
      };
      Writer.prototype.unescapedValue = function unescapedValue(token, context) {
        var value = context.lookup(token[1]);
        if (value != null)
          return value;
      };
      Writer.prototype.escapedValue = function escapedValue(token, context, config) {
        var escape = this.getConfigEscape(config) || mustache.escape;
        var value = context.lookup(token[1]);
        if (value != null)
          return typeof value === "number" && escape === mustache.escape ? String(value) : escape(value);
      };
      Writer.prototype.rawValue = function rawValue(token) {
        return token[1];
      };
      Writer.prototype.getConfigTags = function getConfigTags(config) {
        if (isArray(config)) {
          return config;
        } else if (config && typeof config === "object") {
          return config.tags;
        } else {
          return void 0;
        }
      };
      Writer.prototype.getConfigEscape = function getConfigEscape(config) {
        if (config && typeof config === "object" && !isArray(config)) {
          return config.escape;
        } else {
          return void 0;
        }
      };
      var mustache = {
        name: "mustache.js",
        version: "4.2.0",
        tags: ["{{", "}}"],
        clearCache: void 0,
        escape: void 0,
        parse: void 0,
        render: void 0,
        Scanner: void 0,
        Context: void 0,
        Writer: void 0,
        /**
         * Allows a user to override the default caching strategy, by providing an
         * object with set, get and clear methods. This can also be used to disable
         * the cache by setting it to the literal `undefined`.
         */
        set templateCache(cache) {
          defaultWriter.templateCache = cache;
        },
        /**
         * Gets the default or overridden caching object from the default writer.
         */
        get templateCache() {
          return defaultWriter.templateCache;
        }
      };
      var defaultWriter = new Writer();
      mustache.clearCache = function clearCache() {
        return defaultWriter.clearCache();
      };
      mustache.parse = function parse(template, tags) {
        return defaultWriter.parse(template, tags);
      };
      mustache.render = function render(template, view, partials, config) {
        if (typeof template !== "string") {
          throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
        }
        return defaultWriter.render(template, view, partials, config);
      };
      mustache.escape = escapeHtml;
      mustache.Scanner = Scanner;
      mustache.Context = Context;
      mustache.Writer = Writer;
      return mustache;
    });
  }
});

// node_modules/@messageformat/core/messageformat.js
var require_messageformat = __commonJS({
  "node_modules/@messageformat/core/messageformat.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.MessageFormat = factory());
    })(exports, function() {
      "use strict";
      var __assign = function() {
        __assign = Object.assign || function __assign2(t2) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t2[p] = s[p];
          }
          return t2;
        };
        return __assign.apply(this, arguments);
      };
      function __values(o2) {
        var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o2[s], i = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i >= o2.length)
                o2 = void 0;
              return {
                value: o2 && o2[i++],
                done: !o2
              };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function __read(o2, n) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i = m2.call(o2), r, ar3 = [], e3;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar3.push(r.value);
        } catch (error) {
          e3 = {
            error
          };
        } finally {
          try {
            if (r && !r.done && (m2 = i["return"]))
              m2.call(i);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar3;
      }
      function __spreadArray(to3, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar3; i < l; i++) {
            if (ar3 || !(i in from)) {
              if (!ar3)
                ar3 = Array.prototype.slice.call(from, 0, i);
              ar3[i] = from[i];
            }
          }
        return to3.concat(ar3 || Array.prototype.slice.call(from));
      }
      typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e3 = new Error(message);
        return e3.name = "SuppressedError", e3.error = error, e3.suppressed = suppressed, e3;
      };
      class DateFormatError extends Error {
        /** @internal */
        constructor(msg, token, type) {
          super(msg);
          this.token = token;
          this.type = type || "error";
        }
      }
      const alpha = (width) => width < 4 ? "short" : width === 4 ? "long" : "narrow";
      const numeric = (width) => width % 2 === 0 ? "2-digit" : "numeric";
      function yearOptions(token, onError) {
        switch (token.char) {
          case "y":
            return {
              year: numeric(token.width)
            };
          case "r":
            return {
              calendar: "gregory",
              year: "numeric"
            };
          case "u":
          case "U":
          case "Y":
          default:
            onError(`${token.desc} is not supported; falling back to year:numeric`, DateFormatError.WARNING);
            return {
              year: "numeric"
            };
        }
      }
      function monthStyle(token, onError) {
        switch (token.width) {
          case 1:
            return "numeric";
          case 2:
            return "2-digit";
          case 3:
            return "short";
          case 4:
            return "long";
          case 5:
            return "narrow";
          default:
            onError(`${token.desc} is not supported with width ${token.width}`);
            return void 0;
        }
      }
      function dayStyle(token, onError) {
        const {
          char,
          desc,
          width
        } = token;
        if (char === "d")
          return numeric(width);
        else {
          onError(`${desc} is not supported`);
          return void 0;
        }
      }
      function weekdayStyle(token, onError) {
        const {
          char,
          desc,
          width
        } = token;
        if ((char === "c" || char === "e") && width < 3) {
          const msg = `Numeric value is not supported for ${desc}; falling back to weekday:short`;
          onError(msg, DateFormatError.WARNING);
        }
        return alpha(width);
      }
      function hourOptions(token) {
        const hour = numeric(token.width);
        let hourCycle;
        switch (token.char) {
          case "h":
            hourCycle = "h12";
            break;
          case "H":
            hourCycle = "h23";
            break;
          case "k":
            hourCycle = "h24";
            break;
          case "K":
            hourCycle = "h11";
            break;
        }
        return hourCycle ? {
          hour,
          hourCycle
        } : {
          hour
        };
      }
      function timeZoneNameStyle(token, onError) {
        const {
          char,
          desc,
          width
        } = token;
        switch (char) {
          case "v":
          case "z":
            return width === 4 ? "long" : "short";
          case "V":
            if (width === 4)
              return "long";
            onError(`${desc} is not supported with width ${width}`);
            return void 0;
          case "X":
            onError(`${desc} is not supported`);
            return void 0;
        }
        return "short";
      }
      function compileOptions(token, onError) {
        switch (token.field) {
          case "era":
            return {
              era: alpha(token.width)
            };
          case "year":
            return yearOptions(token, onError);
          case "month":
            return {
              month: monthStyle(token, onError)
            };
          case "day":
            return {
              day: dayStyle(token, onError)
            };
          case "weekday":
            return {
              weekday: weekdayStyle(token, onError)
            };
          case "period":
            return void 0;
          case "hour":
            return hourOptions(token);
          case "min":
            return {
              minute: numeric(token.width)
            };
          case "sec":
            return {
              second: numeric(token.width)
            };
          case "tz":
            return {
              timeZoneName: timeZoneNameStyle(token, onError)
            };
          case "quarter":
          case "week":
          case "sec-frac":
          case "ms":
            onError(`${token.desc} is not supported`);
        }
        return void 0;
      }
      function getDateFormatOptions(tokens) {
        let onError = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (error) => {
          throw error;
        };
        const options = {};
        const fields2 = [];
        for (const token of tokens) {
          const {
            error,
            field,
            str
          } = token;
          if (error) {
            const dte = new DateFormatError(error.message, token);
            dte.stack = error.stack;
            onError(dte);
          }
          if (str) {
            const msg = `Ignoring string part: ${str}`;
            onError(new DateFormatError(msg, token, DateFormatError.WARNING));
          }
          if (field) {
            if (fields2.indexOf(field) === -1)
              fields2.push(field);
            else
              onError(new DateFormatError(`Duplicate ${field} token`, token));
          }
          const opt = compileOptions(token, (msg, isWarning) => onError(new DateFormatError(msg, token, isWarning)));
          if (opt)
            Object.assign(options, opt);
        }
        return options;
      }
      const fields = {
        G: {
          field: "era",
          desc: "Era"
        },
        y: {
          field: "year",
          desc: "Year"
        },
        Y: {
          field: "year",
          desc: 'Year of "Week of Year"'
        },
        u: {
          field: "year",
          desc: "Extended year"
        },
        U: {
          field: "year",
          desc: "Cyclic year name"
        },
        r: {
          field: "year",
          desc: "Related Gregorian year"
        },
        Q: {
          field: "quarter",
          desc: "Quarter"
        },
        q: {
          field: "quarter",
          desc: "Stand-alone quarter"
        },
        M: {
          field: "month",
          desc: "Month in year"
        },
        L: {
          field: "month",
          desc: "Stand-alone month in year"
        },
        w: {
          field: "week",
          desc: "Week of year"
        },
        W: {
          field: "week",
          desc: "Week of month"
        },
        d: {
          field: "day",
          desc: "Day in month"
        },
        D: {
          field: "day",
          desc: "Day of year"
        },
        F: {
          field: "day",
          desc: "Day of week in month"
        },
        g: {
          field: "day",
          desc: "Modified julian day"
        },
        E: {
          field: "weekday",
          desc: "Day of week"
        },
        e: {
          field: "weekday",
          desc: "Local day of week"
        },
        c: {
          field: "weekday",
          desc: "Stand-alone local day of week"
        },
        a: {
          field: "period",
          desc: "AM/PM marker"
        },
        b: {
          field: "period",
          desc: "AM/PM/noon/midnight marker"
        },
        B: {
          field: "period",
          desc: "Flexible day period"
        },
        h: {
          field: "hour",
          desc: "Hour in AM/PM (1~12)"
        },
        H: {
          field: "hour",
          desc: "Hour in day (0~23)"
        },
        k: {
          field: "hour",
          desc: "Hour in day (1~24)"
        },
        K: {
          field: "hour",
          desc: "Hour in AM/PM (0~11)"
        },
        j: {
          field: "hour",
          desc: "Hour in preferred cycle"
        },
        J: {
          field: "hour",
          desc: "Hour in preferred cycle without marker"
        },
        C: {
          field: "hour",
          desc: "Hour in preferred cycle with flexible marker"
        },
        m: {
          field: "min",
          desc: "Minute in hour"
        },
        s: {
          field: "sec",
          desc: "Second in minute"
        },
        S: {
          field: "sec-frac",
          desc: "Fractional second"
        },
        A: {
          field: "ms",
          desc: "Milliseconds in day"
        },
        z: {
          field: "tz",
          desc: "Time Zone: specific non-location"
        },
        Z: {
          field: "tz",
          desc: "Time Zone"
        },
        O: {
          field: "tz",
          desc: "Time Zone: localized"
        },
        v: {
          field: "tz",
          desc: "Time Zone: generic non-location"
        },
        V: {
          field: "tz",
          desc: "Time Zone: ID"
        },
        X: {
          field: "tz",
          desc: "Time Zone: ISO8601 with Z"
        },
        x: {
          field: "tz",
          desc: "Time Zone: ISO8601"
        }
      };
      const isLetter = (char) => char >= "A" && char <= "Z" || char >= "a" && char <= "z";
      function readFieldToken(src, pos) {
        const char = src[pos];
        let width = 1;
        while (src[++pos] === char)
          ++width;
        const field = fields[char];
        if (!field) {
          const msg = `The letter ${char} is not a valid field identifier`;
          return {
            char,
            error: new Error(msg),
            width
          };
        }
        return {
          char,
          field: field.field,
          desc: field.desc,
          width
        };
      }
      function readQuotedToken(src, pos) {
        let str = src[++pos];
        let width = 2;
        if (str === "'")
          return {
            char: "'",
            str,
            width
          };
        while (true) {
          const next = src[++pos];
          ++width;
          if (next === void 0) {
            const msg = `Unterminated quoted literal in pattern: ${str || src}`;
            return {
              char: "'",
              error: new Error(msg),
              str,
              width
            };
          } else if (next === "'") {
            if (src[++pos] !== "'")
              return {
                char: "'",
                str,
                width
              };
            else
              ++width;
          }
          str += next;
        }
      }
      function readToken(src, pos) {
        const char = src[pos];
        if (!char)
          return null;
        if (isLetter(char))
          return readFieldToken(src, pos);
        if (char === "'")
          return readQuotedToken(src, pos);
        let str = char;
        let width = 1;
        while (true) {
          const next = src[++pos];
          if (!next || isLetter(next) || next === "'")
            return {
              char,
              str,
              width
            };
          str += next;
          width += 1;
        }
      }
      function parseDateTokens(src) {
        const tokens = [];
        let pos = 0;
        while (true) {
          const token = readToken(src, pos);
          if (!token)
            return tokens;
          tokens.push(token);
          pos += token.width;
        }
      }
      function getDateFormatter(locales, tokens, onError) {
        if (typeof tokens === "string")
          tokens = parseDateTokens(tokens);
        const opt = getDateFormatOptions(tokens, onError);
        const dtf = new Intl.DateTimeFormat(locales, opt);
        return (date2) => dtf.format(date2);
      }
      function getDateFormatterSource(locales, tokens, onError) {
        if (typeof tokens === "string")
          tokens = parseDateTokens(tokens);
        const opt = getDateFormatOptions(tokens, onError);
        const lines = [`(function() {`, `var opt = ${JSON.stringify(opt)};`, `var dtf = new Intl.DateTimeFormat(${JSON.stringify(locales)}, opt);`, `return function(value) { return dtf.format(value); }`];
        return lines.join("\n  ") + "\n})()";
      }
      class NumberFormatError extends Error {
        /** @internal */
        constructor(code, msg) {
          super(msg);
          this.code = code;
        }
      }
      class BadOptionError extends NumberFormatError {
        constructor(stem, opt) {
          super("BAD_OPTION", `Unknown ${stem} option: ${opt}`);
          this.stem = stem;
          this.option = opt;
        }
      }
      class BadStemError extends NumberFormatError {
        constructor(stem) {
          super("BAD_STEM", `Unknown stem: ${stem}`);
          this.stem = stem;
        }
      }
      class MaskedValueError extends NumberFormatError {
        constructor(type, prev) {
          super("MASKED_VALUE", `Value for ${type} is set multiple times`);
          this.type = type;
          this.prev = prev;
        }
      }
      class MissingOptionError extends NumberFormatError {
        constructor(stem) {
          super("MISSING_OPTION", `Required option missing for ${stem}`);
          this.stem = stem;
        }
      }
      class PatternError extends NumberFormatError {
        constructor(char, msg) {
          super("BAD_PATTERN", msg);
          this.char = char;
        }
      }
      class TooManyOptionsError extends NumberFormatError {
        constructor(stem, options, maxOpt) {
          const maxOptStr = maxOpt > 1 ? `${maxOpt} options` : "one option";
          super("TOO_MANY_OPTIONS", `Token ${stem} only supports ${maxOptStr} (got ${options.length})`);
          this.stem = stem;
          this.options = options;
        }
      }
      class UnsupportedError extends NumberFormatError {
        constructor(stem, source) {
          super("UNSUPPORTED", `The stem ${stem} is not supported`);
          this.stem = stem;
          if (source) {
            this.message += ` with value ${source}`;
            this.source = source;
          }
        }
      }
      function getNumberFormatLocales(locales, _ref) {
        let {
          numberingSystem
        } = _ref;
        if (!Array.isArray(locales))
          locales = [locales];
        return numberingSystem ? locales.map((lc) => {
          const ext = lc.indexOf("-u-") === -1 ? "u-nu" : "nu";
          return `${lc}-${ext}-${numberingSystem}`;
        }).concat(locales) : locales;
      }
      function round(x2, precision) {
        const y = +x2 + precision / 2;
        return y - y % +precision;
      }
      function getNumberFormatMultiplier(_ref) {
        let {
          scale,
          unit
        } = _ref;
        let mult = typeof scale === "number" && scale >= 0 ? scale : 1;
        if (unit && unit.style === "percent")
          mult *= 0.01;
        return mult;
      }
      function getNumberFormatModifier(skeleton) {
        const mult = getNumberFormatMultiplier(skeleton);
        const {
          precision
        } = skeleton;
        if (precision && precision.style === "precision-increment") {
          return (n) => round(n, precision.increment) * mult;
        } else {
          return (n) => n * mult;
        }
      }
      function getNumberFormatModifierSource(skeleton) {
        const mult = getNumberFormatMultiplier(skeleton);
        const {
          precision
        } = skeleton;
        if (precision && precision.style === "precision-increment") {
          const setX = `+n + ${precision.increment / 2}`;
          let res = `x - (x % +${precision.increment})`;
          if (mult !== 1)
            res = `(${res}) * ${mult}`;
          return `function(n) { var x = ${setX}; return ${res}; }`;
        }
        return mult !== 1 ? `function(n) { return n * ${mult}; }` : null;
      }
      function getNumberFormatOptions(skeleton, onUnsupported) {
        const {
          decimal,
          group,
          integerWidth,
          notation,
          precision,
          roundingMode,
          sign,
          unit,
          unitPer,
          unitWidth
        } = skeleton;
        const fail = (stem, source) => {
          if (onUnsupported)
            onUnsupported(new UnsupportedError(stem, source));
        };
        const opt = {};
        if (unit) {
          switch (unit.style) {
            case "base-unit":
              opt.style = "decimal";
              break;
            case "currency":
              opt.style = "currency";
              opt.currency = unit.currency;
              break;
            case "measure-unit":
              opt.style = "unit";
              opt.unit = unit.unit.replace(/.*-/, "");
              if (unitPer)
                opt.unit += "-per-" + unitPer.replace(/.*-/, "");
              break;
            case "percent":
              opt.style = "percent";
              break;
            case "permille":
              fail("permille");
              break;
          }
        }
        switch (unitWidth) {
          case "unit-width-full-name":
            opt.currencyDisplay = "name";
            opt.unitDisplay = "long";
            break;
          case "unit-width-hidden":
            fail(unitWidth);
            break;
          case "unit-width-iso-code":
            opt.currencyDisplay = "code";
            break;
          case "unit-width-narrow":
            opt.currencyDisplay = "narrowSymbol";
            opt.unitDisplay = "narrow";
            break;
          case "unit-width-short":
            opt.currencyDisplay = "symbol";
            opt.unitDisplay = "short";
            break;
        }
        switch (group) {
          case "group-off":
            opt.useGrouping = false;
            break;
          case "group-auto":
            opt.useGrouping = true;
            break;
          case "group-min2":
          case "group-on-aligned":
          case "group-thousands":
            fail(group);
            opt.useGrouping = true;
            break;
        }
        if (precision) {
          switch (precision.style) {
            case "precision-fraction": {
              const {
                minFraction: minF,
                maxFraction: maxF,
                minSignificant: minS,
                maxSignificant: maxS,
                source
              } = precision;
              if (typeof minF === "number") {
                opt.minimumFractionDigits = minF;
                if (typeof minS === "number")
                  fail("precision-fraction", source);
              }
              if (typeof maxF === "number")
                opt.maximumFractionDigits = maxF;
              if (typeof minS === "number")
                opt.minimumSignificantDigits = minS;
              if (typeof maxS === "number")
                opt.maximumSignificantDigits = maxS;
              break;
            }
            case "precision-integer":
              opt.maximumFractionDigits = 0;
              break;
            case "precision-unlimited":
              opt.maximumFractionDigits = 20;
              break;
            case "precision-increment":
              break;
            case "precision-currency-standard":
              opt.trailingZeroDisplay = precision.trailingZero;
              break;
            case "precision-currency-cash":
              fail(precision.style);
              break;
          }
        }
        if (notation) {
          switch (notation.style) {
            case "compact-short":
              opt.notation = "compact";
              opt.compactDisplay = "short";
              break;
            case "compact-long":
              opt.notation = "compact";
              opt.compactDisplay = "long";
              break;
            case "notation-simple":
              opt.notation = "standard";
              break;
            case "scientific":
            case "engineering": {
              const {
                expDigits,
                expSign,
                source,
                style
              } = notation;
              opt.notation = style;
              if (expDigits && expDigits > 1 || expSign && expSign !== "sign-auto")
                fail(style, source);
              break;
            }
          }
        }
        if (integerWidth) {
          const {
            min,
            max,
            source
          } = integerWidth;
          if (min > 0)
            opt.minimumIntegerDigits = min;
          if (Number(max) > 0) {
            const hasExp = opt.notation === "engineering" || opt.notation === "scientific";
            if (max === 3 && hasExp)
              opt.notation = "engineering";
            else
              fail("integer-width", source);
          }
        }
        switch (sign) {
          case "sign-auto":
            opt.signDisplay = "auto";
            break;
          case "sign-always":
            opt.signDisplay = "always";
            break;
          case "sign-except-zero":
            opt.signDisplay = "exceptZero";
            break;
          case "sign-never":
            opt.signDisplay = "never";
            break;
          case "sign-accounting":
            opt.currencySign = "accounting";
            break;
          case "sign-accounting-always":
            opt.currencySign = "accounting";
            opt.signDisplay = "always";
            break;
          case "sign-accounting-except-zero":
            opt.currencySign = "accounting";
            opt.signDisplay = "exceptZero";
            break;
        }
        if (decimal === "decimal-always")
          fail(decimal);
        if (roundingMode)
          fail(roundingMode);
        return opt;
      }
      function parseAffixToken(src, pos, onError) {
        const char = src[pos];
        switch (char) {
          case "%":
            return {
              char: "%",
              style: "percent",
              width: 1
            };
          case "":
            return {
              char: "%",
              style: "permille",
              width: 1
            };
          case "": {
            let width = 1;
            while (src[++pos] === "")
              ++width;
            switch (width) {
              case 1:
                return {
                  char,
                  currency: "default",
                  width
                };
              case 2:
                return {
                  char,
                  currency: "iso-code",
                  width
                };
              case 3:
                return {
                  char,
                  currency: "full-name",
                  width
                };
              case 5:
                return {
                  char,
                  currency: "narrow",
                  width
                };
              default: {
                const msg = `Invalid number (${width}) of  chars in pattern`;
                onError(new PatternError("", msg));
                return null;
              }
            }
          }
          case "*": {
            const pad = src[pos + 1];
            if (pad)
              return {
                char,
                pad,
                width: 2
              };
            break;
          }
          case "+":
          case "-":
            return {
              char,
              width: 1
            };
          case "'": {
            let str = src[++pos];
            let width = 2;
            if (str === "'")
              return {
                char,
                str,
                width
              };
            while (true) {
              const next = src[++pos];
              ++width;
              if (next === void 0) {
                const msg = `Unterminated quoted literal in pattern: ${str}`;
                onError(new PatternError("'", msg));
                return {
                  char,
                  str,
                  width
                };
              } else if (next === "'") {
                if (src[++pos] !== "'")
                  return {
                    char,
                    str,
                    width
                  };
                else
                  ++width;
              }
              str += next;
            }
          }
        }
        return null;
      }
      const isDigit = (char) => char >= "0" && char <= "9";
      function parseNumberToken(src, pos) {
        const char = src[pos];
        if (isDigit(char)) {
          let digits = char;
          while (true) {
            const next = src[++pos];
            if (isDigit(next))
              digits += next;
            else
              return {
                char: "0",
                digits,
                width: digits.length
              };
          }
        }
        switch (char) {
          case "#": {
            let width = 1;
            while (src[++pos] === "#")
              ++width;
            return {
              char,
              width
            };
          }
          case "@": {
            let min = 1;
            while (src[++pos] === "@")
              ++min;
            let width = min;
            pos -= 1;
            while (src[++pos] === "#")
              ++width;
            return {
              char,
              min,
              width
            };
          }
          case "E": {
            const plus = src[pos + 1] === "+";
            if (plus)
              ++pos;
            let expDigits = 0;
            while (src[++pos] === "0")
              ++expDigits;
            const width = (plus ? 2 : 1) + expDigits;
            if (expDigits)
              return {
                char,
                expDigits,
                plus,
                width
              };
            else
              break;
          }
          case ".":
          case ",":
            return {
              char,
              width: 1
            };
        }
        return null;
      }
      function parseSubpattern(src, pos, onError) {
        let State;
        (function(State2) {
          State2[State2["Prefix"] = 0] = "Prefix";
          State2[State2["Number"] = 1] = "Number";
          State2[State2["Suffix"] = 2] = "Suffix";
        })(State || (State = {}));
        const prefix = [];
        const number2 = [];
        const suffix = [];
        let state = State.Prefix;
        let str = "";
        while (pos < src.length) {
          const char = src[pos];
          if (char === ";") {
            pos += 1;
            break;
          }
          switch (state) {
            case State.Prefix: {
              const token = parseAffixToken(src, pos, onError);
              if (token) {
                if (str) {
                  prefix.push({
                    char: "'",
                    str,
                    width: str.length
                  });
                  str = "";
                }
                prefix.push(token);
                pos += token.width;
              } else {
                const token2 = parseNumberToken(src, pos);
                if (token2) {
                  if (str) {
                    prefix.push({
                      char: "'",
                      str,
                      width: str.length
                    });
                    str = "";
                  }
                  state = State.Number;
                  number2.push(token2);
                  pos += token2.width;
                } else {
                  str += char;
                  pos += 1;
                }
              }
              break;
            }
            case State.Number: {
              const token = parseNumberToken(src, pos);
              if (token) {
                number2.push(token);
                pos += token.width;
              } else {
                state = State.Suffix;
              }
              break;
            }
            case State.Suffix: {
              const token = parseAffixToken(src, pos, onError);
              if (token) {
                if (str) {
                  suffix.push({
                    char: "'",
                    str,
                    width: str.length
                  });
                  str = "";
                }
                suffix.push(token);
                pos += token.width;
              } else {
                str += char;
                pos += 1;
              }
              break;
            }
          }
        }
        if (str)
          suffix.push({
            char: "'",
            str,
            width: str.length
          });
        return {
          pattern: {
            prefix,
            number: number2,
            suffix
          },
          pos
        };
      }
      function parseTokens(src, onError) {
        const {
          pattern,
          pos
        } = parseSubpattern(src, 0, onError);
        if (pos < src.length) {
          const {
            pattern: negative
          } = parseSubpattern(src, pos, onError);
          return {
            tokens: pattern,
            negative
          };
        }
        return {
          tokens: pattern
        };
      }
      function parseNumberAsSkeleton(tokens, onError) {
        const res = {};
        let hasGroups = false;
        let hasExponent = false;
        let intOptional = 0;
        let intDigits = "";
        let decimalPos = -1;
        let fracDigits = "";
        let fracOptional = 0;
        for (let pos = 0; pos < tokens.length; ++pos) {
          const token = tokens[pos];
          switch (token.char) {
            case "#": {
              if (decimalPos === -1) {
                if (intDigits) {
                  const msg = "Pattern has # after integer digits";
                  onError(new PatternError("#", msg));
                }
                intOptional += token.width;
              } else {
                fracOptional += token.width;
              }
              break;
            }
            case "0": {
              if (decimalPos === -1) {
                intDigits += token.digits;
              } else {
                if (fracOptional) {
                  const msg = "Pattern has digits after # in fraction";
                  onError(new PatternError("0", msg));
                }
                fracDigits += token.digits;
              }
              break;
            }
            case "@": {
              if (res.precision)
                onError(new MaskedValueError("precision", res.precision));
              res.precision = {
                style: "precision-fraction",
                minSignificant: token.min,
                maxSignificant: token.width
              };
              break;
            }
            case ",":
              hasGroups = true;
              break;
            case ".":
              if (decimalPos === 1) {
                const msg = "Pattern has more than one decimal separator";
                onError(new PatternError(".", msg));
              }
              decimalPos = pos;
              break;
            case "E": {
              if (hasExponent)
                onError(new MaskedValueError("exponent", res.notation));
              if (hasGroups) {
                const msg = "Exponential patterns may not contain grouping separators";
                onError(new PatternError("E", msg));
              }
              res.notation = {
                style: "scientific"
              };
              if (token.expDigits > 1)
                res.notation.expDigits = token.expDigits;
              if (token.plus)
                res.notation.expSign = "sign-always";
              hasExponent = true;
            }
          }
        }
        if (hasGroups)
          res.group = "group-auto";
        else if (intOptional + intDigits.length > 3)
          res.group = "group-off";
        const increment = Number(`${intDigits || "0"}.${fracDigits}`);
        if (increment)
          res.precision = {
            style: "precision-increment",
            increment
          };
        if (!hasExponent) {
          if (intDigits.length > 1)
            res.integerWidth = {
              min: intDigits.length
            };
          if (!res.precision && (fracDigits.length || fracOptional)) {
            res.precision = {
              style: "precision-fraction",
              minFraction: fracDigits.length,
              maxFraction: fracDigits.length + fracOptional
            };
          }
        } else {
          if (!res.precision || increment) {
            res.integerWidth = intOptional ? {
              min: 1,
              max: intOptional + intDigits.length
            } : {
              min: Math.max(1, intDigits.length)
            };
          }
          if (res.precision) {
            if (!increment)
              res.integerWidth = {
                min: 1,
                max: 1
              };
          } else {
            const dc = intDigits.length + fracDigits.length;
            if (decimalPos === -1) {
              if (dc > 0)
                res.precision = {
                  style: "precision-fraction",
                  maxSignificant: dc
                };
            } else {
              res.precision = {
                style: "precision-fraction",
                maxSignificant: Math.max(1, dc) + fracOptional
              };
              if (dc > 1)
                res.precision.minSignificant = dc;
            }
          }
        }
        return res;
      }
      function handleAffix(affixTokens, res, currency, onError, isPrefix) {
        let inFmt = false;
        let str = "";
        for (const token of affixTokens) {
          switch (token.char) {
            case "%":
              res.unit = {
                style: token.style
              };
              if (isPrefix)
                inFmt = true;
              else
                str = "";
              break;
            case "":
              if (!currency) {
                const msg = `The  pattern requires a currency`;
                onError(new PatternError("", msg));
                break;
              }
              res.unit = {
                style: "currency",
                currency
              };
              switch (token.currency) {
                case "iso-code":
                  res.unitWidth = "unit-width-iso-code";
                  break;
                case "full-name":
                  res.unitWidth = "unit-width-full-name";
                  break;
                case "narrow":
                  res.unitWidth = "unit-width-narrow";
                  break;
              }
              if (isPrefix)
                inFmt = true;
              else
                str = "";
              break;
            case "*":
              break;
            case "+":
              if (!inFmt)
                str += "+";
              break;
            case "'":
              if (!inFmt)
                str += token.str;
              break;
          }
        }
        return str;
      }
      function getNegativeAffix(affixTokens, isPrefix) {
        let inFmt = false;
        let str = "";
        for (const token of affixTokens) {
          switch (token.char) {
            case "%":
            case "":
              if (isPrefix)
                inFmt = true;
              else
                str = "";
              break;
            case "-":
              if (!inFmt)
                str += "-";
              break;
            case "'":
              if (!inFmt)
                str += token.str;
              break;
          }
        }
        return str;
      }
      function parseNumberPattern(src, currency) {
        let onError = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (error) => {
          throw error;
        };
        const {
          tokens,
          negative
        } = parseTokens(src, onError);
        const res = parseNumberAsSkeleton(tokens.number, onError);
        const prefix = handleAffix(tokens.prefix, res, currency, onError, true);
        const suffix = handleAffix(tokens.suffix, res, currency, onError, false);
        if (negative) {
          const negPrefix = getNegativeAffix(negative.prefix, true);
          const negSuffix = getNegativeAffix(negative.suffix, false);
          res.affix = {
            pos: [prefix, suffix],
            neg: [negPrefix, negSuffix]
          };
          res.sign = "sign-never";
        } else if (prefix || suffix) {
          res.affix = {
            pos: [prefix, suffix]
          };
        }
        return res;
      }
      function isNumberingSystem(ns) {
        const systems = ["arab", "arabext", "bali", "beng", "deva", "fullwide", "gujr", "guru", "hanidec", "khmr", "knda", "laoo", "latn", "limb", "mlym", "mong", "mymr", "orya", "tamldec", "telu", "thai", "tibt"];
        return systems.indexOf(ns) !== -1;
      }
      function isUnit(unit) {
        const types = ["acceleration", "angle", "area", "concentr", "consumption", "digital", "duration", "electric", "energy", "force", "frequency", "graphics", "length", "light", "mass", "power", "pressure", "speed", "temperature", "torque", "volume"];
        const [type] = unit.split("-", 1);
        return types.indexOf(type) !== -1;
      }
      const maxOptions = {
        "compact-short": 0,
        "compact-long": 0,
        "notation-simple": 0,
        scientific: 2,
        engineering: 2,
        percent: 0,
        permille: 0,
        "base-unit": 0,
        currency: 1,
        "measure-unit": 1,
        "per-measure-unit": 1,
        "unit-width-narrow": 0,
        "unit-width-short": 0,
        "unit-width-full-name": 0,
        "unit-width-iso-code": 0,
        "unit-width-hidden": 0,
        "precision-integer": 0,
        "precision-unlimited": 0,
        "precision-currency-standard": 1,
        "precision-currency-cash": 0,
        "precision-increment": 1,
        "rounding-mode-ceiling": 0,
        "rounding-mode-floor": 0,
        "rounding-mode-down": 0,
        "rounding-mode-up": 0,
        "rounding-mode-half-even": 0,
        "rounding-mode-half-down": 0,
        "rounding-mode-half-up": 0,
        "rounding-mode-unnecessary": 0,
        "integer-width": 1,
        scale: 1,
        "group-off": 0,
        "group-min2": 0,
        "group-auto": 0,
        "group-on-aligned": 0,
        "group-thousands": 0,
        latin: 0,
        "numbering-system": 1,
        "sign-auto": 0,
        "sign-always": 0,
        "sign-never": 0,
        "sign-accounting": 0,
        "sign-accounting-always": 0,
        "sign-except-zero": 0,
        "sign-accounting-except-zero": 0,
        "decimal-auto": 0,
        "decimal-always": 0
      };
      const minOptions = {
        currency: 1,
        "integer-width": 1,
        "measure-unit": 1,
        "numbering-system": 1,
        "per-measure-unit": 1,
        "precision-increment": 1,
        scale: 1
      };
      function hasMaxOption(stem) {
        return stem in maxOptions;
      }
      function hasMinOption(stem) {
        return stem in minOptions;
      }
      function validOptions(stem, options, onError) {
        if (hasMaxOption(stem)) {
          const maxOpt = maxOptions[stem];
          if (options.length > maxOpt) {
            if (maxOpt === 0) {
              for (const opt of options)
                onError(new BadOptionError(stem, opt));
            } else {
              onError(new TooManyOptionsError(stem, options, maxOpt));
            }
            return false;
          } else if (hasMinOption(stem) && options.length < minOptions[stem]) {
            onError(new MissingOptionError(stem));
            return false;
          }
        }
        return true;
      }
      function parseBlueprintDigits(src, style) {
        const re = style === "fraction" ? /^\.(0*)(\+|#*)$/ : /^(@+)(\+|#*)$/;
        const match = src && src.match(re);
        if (match) {
          const min = match[1].length;
          switch (match[2].charAt(0)) {
            case "":
              return {
                min,
                max: min
              };
            case "+":
              return {
                min,
                max: null
              };
            case "#": {
              return {
                min,
                max: min + match[2].length
              };
            }
          }
        }
        return null;
      }
      function parsePrecisionBlueprint(stem, options, onError) {
        const fd = parseBlueprintDigits(stem, "fraction");
        if (fd) {
          if (options.length > 1)
            onError(new TooManyOptionsError(stem, options, 1));
          const res = {
            style: "precision-fraction",
            source: stem,
            minFraction: fd.min
          };
          if (fd.max != null)
            res.maxFraction = fd.max;
          const option = options[0];
          const sd4 = parseBlueprintDigits(option, "significant");
          if (sd4) {
            res.source = `${stem}/${option}`;
            res.minSignificant = sd4.min;
            if (sd4.max != null)
              res.maxSignificant = sd4.max;
          } else if (option)
            onError(new BadOptionError(stem, option));
          return res;
        }
        const sd3 = parseBlueprintDigits(stem, "significant");
        if (sd3) {
          for (const opt of options)
            onError(new BadOptionError(stem, opt));
          const res = {
            style: "precision-fraction",
            source: stem,
            minSignificant: sd3.min
          };
          if (sd3.max != null)
            res.maxSignificant = sd3.max;
          return res;
        }
        return null;
      }
      class TokenParser {
        constructor(onError) {
          this.skeleton = {};
          this.onError = onError;
        }
        badOption(stem, opt) {
          this.onError(new BadOptionError(stem, opt));
        }
        assertEmpty(key) {
          const prev = this.skeleton[key];
          if (prev)
            this.onError(new MaskedValueError(key, prev));
        }
        parseToken(stem, options) {
          if (!validOptions(stem, options, this.onError))
            return;
          const option = options[0];
          const res = this.skeleton;
          switch (stem) {
            case "compact-short":
            case "compact-long":
            case "notation-simple":
              this.assertEmpty("notation");
              res.notation = {
                style: stem
              };
              break;
            case "scientific":
            case "engineering": {
              let expDigits = null;
              let expSign = void 0;
              for (const opt of options) {
                switch (opt) {
                  case "sign-auto":
                  case "sign-always":
                  case "sign-never":
                  case "sign-accounting":
                  case "sign-accounting-always":
                  case "sign-except-zero":
                  case "sign-accounting-except-zero":
                    expSign = opt;
                    break;
                  default:
                    if (/^\+e+$/.test(opt))
                      expDigits = opt.length - 1;
                    else {
                      this.badOption(stem, opt);
                    }
                }
              }
              this.assertEmpty("notation");
              const source = options.join("/");
              res.notation = expDigits && expSign ? {
                style: stem,
                source,
                expDigits,
                expSign
              } : expDigits ? {
                style: stem,
                source,
                expDigits
              } : expSign ? {
                style: stem,
                source,
                expSign
              } : {
                style: stem,
                source
              };
              break;
            }
            case "percent":
            case "permille":
            case "base-unit":
              this.assertEmpty("unit");
              res.unit = {
                style: stem
              };
              break;
            case "currency":
              if (/^[A-Z]{3}$/.test(option)) {
                this.assertEmpty("unit");
                res.unit = {
                  style: stem,
                  currency: option
                };
              } else
                this.badOption(stem, option);
              break;
            case "measure-unit": {
              if (isUnit(option)) {
                this.assertEmpty("unit");
                res.unit = {
                  style: stem,
                  unit: option
                };
              } else
                this.badOption(stem, option);
              break;
            }
            case "per-measure-unit": {
              if (isUnit(option)) {
                this.assertEmpty("unitPer");
                res.unitPer = option;
              } else
                this.badOption(stem, option);
              break;
            }
            case "unit-width-narrow":
            case "unit-width-short":
            case "unit-width-full-name":
            case "unit-width-iso-code":
            case "unit-width-hidden":
              this.assertEmpty("unitWidth");
              res.unitWidth = stem;
              break;
            case "precision-integer":
            case "precision-unlimited":
            case "precision-currency-cash":
              this.assertEmpty("precision");
              res.precision = {
                style: stem
              };
              break;
            case "precision-currency-standard":
              this.assertEmpty("precision");
              if (option === "w") {
                res.precision = {
                  style: stem,
                  trailingZero: "stripIfInteger"
                };
              } else {
                res.precision = {
                  style: stem
                };
              }
              break;
            case "precision-increment": {
              const increment = Number(option);
              if (increment > 0) {
                this.assertEmpty("precision");
                res.precision = {
                  style: stem,
                  increment
                };
              } else
                this.badOption(stem, option);
              break;
            }
            case "rounding-mode-ceiling":
            case "rounding-mode-floor":
            case "rounding-mode-down":
            case "rounding-mode-up":
            case "rounding-mode-half-even":
            case "rounding-mode-half-odd":
            case "rounding-mode-half-ceiling":
            case "rounding-mode-half-floor":
            case "rounding-mode-half-down":
            case "rounding-mode-half-up":
            case "rounding-mode-unnecessary":
              this.assertEmpty("roundingMode");
              res.roundingMode = stem;
              break;
            case "integer-width": {
              if (/^\+0*$/.test(option)) {
                this.assertEmpty("integerWidth");
                res.integerWidth = {
                  source: option,
                  min: option.length - 1
                };
              } else {
                const m2 = option.match(/^#*(0*)$/);
                if (m2) {
                  this.assertEmpty("integerWidth");
                  res.integerWidth = {
                    source: option,
                    min: m2[1].length,
                    max: m2[0].length
                  };
                } else
                  this.badOption(stem, option);
              }
              break;
            }
            case "scale": {
              const scale = Number(option);
              if (scale > 0) {
                this.assertEmpty("scale");
                res.scale = scale;
              } else
                this.badOption(stem, option);
              break;
            }
            case "group-off":
            case "group-min2":
            case "group-auto":
            case "group-on-aligned":
            case "group-thousands":
              this.assertEmpty("group");
              res.group = stem;
              break;
            case "latin":
              this.assertEmpty("numberingSystem");
              res.numberingSystem = "latn";
              break;
            case "numbering-system": {
              if (isNumberingSystem(option)) {
                this.assertEmpty("numberingSystem");
                res.numberingSystem = option;
              } else
                this.badOption(stem, option);
              break;
            }
            case "sign-auto":
            case "sign-always":
            case "sign-never":
            case "sign-accounting":
            case "sign-accounting-always":
            case "sign-except-zero":
            case "sign-accounting-except-zero":
              this.assertEmpty("sign");
              res.sign = stem;
              break;
            case "decimal-auto":
            case "decimal-always":
              this.assertEmpty("decimal");
              res.decimal = stem;
              break;
            default: {
              const precision = parsePrecisionBlueprint(stem, options, this.onError);
              if (precision) {
                this.assertEmpty("precision");
                res.precision = precision;
              } else {
                this.onError(new BadStemError(stem));
              }
            }
          }
        }
      }
      function parseNumberSkeleton(src) {
        let onError = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (error) => {
          throw error;
        };
        const tokens = [];
        for (const part of src.split(" ")) {
          if (part) {
            const options = part.split("/");
            const stem = options.shift() || "";
            tokens.push({
              stem,
              options
            });
          }
        }
        const parser2 = new TokenParser(onError);
        for (const {
          stem,
          options
        } of tokens) {
          parser2.parseToken(stem, options);
        }
        return parser2.skeleton;
      }
      function getNumberFormatter(locales, skeleton, currency, onError) {
        if (typeof skeleton === "string") {
          skeleton = skeleton.indexOf("::") === 0 ? parseNumberSkeleton(skeleton.slice(2), onError) : parseNumberPattern(skeleton, currency, onError);
        }
        const lc = getNumberFormatLocales(locales, skeleton);
        const opt = getNumberFormatOptions(skeleton, onError);
        const mod = getNumberFormatModifier(skeleton);
        const nf2 = new Intl.NumberFormat(lc, opt);
        if (skeleton.affix) {
          const [p0, p1] = skeleton.affix.pos;
          const [n0, n1] = skeleton.affix.neg || ["", ""];
          return (value) => {
            const n = nf2.format(mod(value));
            return value < 0 ? `${n0}${n}${n1}` : `${p0}${n}${p1}`;
          };
        }
        return (value) => nf2.format(mod(value));
      }
      function getNumberFormatterSource(locales, skeleton, currency, onError) {
        if (typeof skeleton === "string") {
          skeleton = skeleton.indexOf("::") === 0 ? parseNumberSkeleton(skeleton.slice(2), onError) : parseNumberPattern(skeleton, currency, onError);
        }
        const lc = getNumberFormatLocales(locales, skeleton);
        const opt = getNumberFormatOptions(skeleton, onError);
        const modSrc = getNumberFormatModifierSource(skeleton);
        const lines = [`(function() {`, `var opt = ${JSON.stringify(opt)};`, `var nf = new Intl.NumberFormat(${JSON.stringify(lc)}, opt);`];
        let res = "nf.format(value)";
        if (modSrc) {
          lines.push(`var mod = ${modSrc};`);
          res = "nf.format(mod(value))";
        }
        if (skeleton.affix) {
          const [p0, p1] = skeleton.affix.pos.map((s) => JSON.stringify(s));
          if (skeleton.affix.neg) {
            const [n0, n1] = skeleton.affix.neg.map((s) => JSON.stringify(s));
            res = `value < 0 ? ${n0} + ${res} + ${n1} : ${p0} + ${res} + ${p1}`;
          } else {
            res = `${p0} + ${res} + ${p1}`;
          }
        }
        lines.push(`return function(value) { return ${res}; }`);
        return lines.join("\n  ") + "\n})()";
      }
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getDefaultExportFromCjs(x2) {
        return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
      }
      var parser = {};
      var lexer = {};
      var moo = { exports: {} };
      (function(module2) {
        (function(root, factory) {
          if (module2.exports) {
            module2.exports = factory();
          } else {
            root.moo = factory();
          }
        })(commonjsGlobal, function() {
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var toString = Object.prototype.toString;
          var hasSticky = typeof new RegExp().sticky === "boolean";
          function isRegExp(o2) {
            return o2 && toString.call(o2) === "[object RegExp]";
          }
          function isObject(o2) {
            return o2 && typeof o2 === "object" && !isRegExp(o2) && !Array.isArray(o2);
          }
          function reEscape(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
          }
          function reGroups(s) {
            var re = new RegExp("|" + s);
            return re.exec("").length - 1;
          }
          function reCapture(s) {
            return "(" + s + ")";
          }
          function reUnion(regexps) {
            if (!regexps.length)
              return "(?!)";
            var source = regexps.map(function(s) {
              return "(?:" + s + ")";
            }).join("|");
            return "(?:" + source + ")";
          }
          function regexpOrLiteral(obj) {
            if (typeof obj === "string") {
              return "(?:" + reEscape(obj) + ")";
            } else if (isRegExp(obj)) {
              if (obj.ignoreCase)
                throw new Error("RegExp /i flag not allowed");
              if (obj.global)
                throw new Error("RegExp /g flag is implied");
              if (obj.sticky)
                throw new Error("RegExp /y flag is implied");
              if (obj.multiline)
                throw new Error("RegExp /m flag is implied");
              return obj.source;
            } else {
              throw new Error("Not a pattern: " + obj);
            }
          }
          function pad(s, length) {
            if (s.length > length) {
              return s;
            }
            return Array(length - s.length + 1).join(" ") + s;
          }
          function lastNLines(string, numLines) {
            var position = string.length;
            var lineBreaks = 0;
            while (true) {
              var idx = string.lastIndexOf("\n", position - 1);
              if (idx === -1) {
                break;
              } else {
                lineBreaks++;
              }
              position = idx;
              if (lineBreaks === numLines) {
                break;
              }
              if (position === 0) {
                break;
              }
            }
            var startPosition = lineBreaks < numLines ? 0 : position + 1;
            return string.substring(startPosition).split("\n");
          }
          function objectToRules(object) {
            var keys = Object.getOwnPropertyNames(object);
            var result = [];
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              var thing = object[key];
              var rules = [].concat(thing);
              if (key === "include") {
                for (var j = 0; j < rules.length; j++) {
                  result.push({
                    include: rules[j]
                  });
                }
                continue;
              }
              var match = [];
              rules.forEach(function(rule) {
                if (isObject(rule)) {
                  if (match.length)
                    result.push(ruleOptions(key, match));
                  result.push(ruleOptions(key, rule));
                  match = [];
                } else {
                  match.push(rule);
                }
              });
              if (match.length)
                result.push(ruleOptions(key, match));
            }
            return result;
          }
          function arrayToRules(array) {
            var result = [];
            for (var i = 0; i < array.length; i++) {
              var obj = array[i];
              if (obj.include) {
                var include = [].concat(obj.include);
                for (var j = 0; j < include.length; j++) {
                  result.push({
                    include: include[j]
                  });
                }
                continue;
              }
              if (!obj.type) {
                throw new Error("Rule has no type: " + JSON.stringify(obj));
              }
              result.push(ruleOptions(obj.type, obj));
            }
            return result;
          }
          function ruleOptions(type, obj) {
            if (!isObject(obj)) {
              obj = {
                match: obj
              };
            }
            if (obj.include) {
              throw new Error("Matching rules cannot also include states");
            }
            var options = {
              defaultType: type,
              lineBreaks: !!obj.error || !!obj.fallback,
              pop: false,
              next: null,
              push: null,
              error: false,
              fallback: false,
              value: null,
              type: null,
              shouldThrow: false
            };
            for (var key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                options[key] = obj[key];
              }
            }
            if (typeof options.type === "string" && type !== options.type) {
              throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')");
            }
            var match = options.match;
            options.match = Array.isArray(match) ? match : match ? [match] : [];
            options.match.sort(function(a3, b3) {
              return isRegExp(a3) && isRegExp(b3) ? 0 : isRegExp(b3) ? -1 : isRegExp(a3) ? 1 : b3.length - a3.length;
            });
            return options;
          }
          function toRules(spec) {
            return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
          }
          var defaultErrorRule = ruleOptions("error", {
            lineBreaks: true,
            shouldThrow: true
          });
          function compileRules(rules, hasStates) {
            var errorRule = null;
            var fast = /* @__PURE__ */ Object.create(null);
            var fastAllowed = true;
            var unicodeFlag = null;
            var groups = [];
            var parts = [];
            for (var i = 0; i < rules.length; i++) {
              if (rules[i].fallback) {
                fastAllowed = false;
              }
            }
            for (var i = 0; i < rules.length; i++) {
              var options = rules[i];
              if (options.include) {
                throw new Error("Inheritance is not allowed in stateless lexers");
              }
              if (options.error || options.fallback) {
                if (errorRule) {
                  if (!options.fallback === !errorRule.fallback) {
                    throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')");
                  } else {
                    throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')");
                  }
                }
                errorRule = options;
              }
              var match = options.match.slice();
              if (fastAllowed) {
                while (match.length && typeof match[0] === "string" && match[0].length === 1) {
                  var word = match.shift();
                  fast[word.charCodeAt(0)] = options;
                }
              }
              if (options.pop || options.push || options.next) {
                if (!hasStates) {
                  throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')");
                }
                if (options.fallback) {
                  throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')");
                }
              }
              if (match.length === 0) {
                continue;
              }
              fastAllowed = false;
              groups.push(options);
              for (var j = 0; j < match.length; j++) {
                var obj = match[j];
                if (!isRegExp(obj)) {
                  continue;
                }
                if (unicodeFlag === null) {
                  unicodeFlag = obj.unicode;
                } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
                  throw new Error("If one rule is /u then all must be");
                }
              }
              var pat = reUnion(match.map(regexpOrLiteral));
              var regexp = new RegExp(pat);
              if (regexp.test("")) {
                throw new Error("RegExp matches empty string: " + regexp);
              }
              var groupCount = reGroups(pat);
              if (groupCount > 0) {
                throw new Error("RegExp has capture groups: " + regexp + "\nUse (?:  ) instead");
              }
              if (!options.lineBreaks && regexp.test("\n")) {
                throw new Error("Rule should declare lineBreaks: " + regexp);
              }
              parts.push(reCapture(pat));
            }
            var fallbackRule = errorRule && errorRule.fallback;
            var flags = hasSticky && !fallbackRule ? "ym" : "gm";
            var suffix = hasSticky || fallbackRule ? "" : "|";
            if (unicodeFlag === true)
              flags += "u";
            var combined = new RegExp(reUnion(parts) + suffix, flags);
            return {
              regexp: combined,
              groups,
              fast,
              error: errorRule || defaultErrorRule
            };
          }
          function compile(rules) {
            var result = compileRules(toRules(rules));
            return new Lexer({
              start: result
            }, "start");
          }
          function checkStateGroup(g, name, map) {
            var state = g && (g.push || g.next);
            if (state && !map[state]) {
              throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name + "')");
            }
            if (g && g.pop && +g.pop !== 1) {
              throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name + "')");
            }
          }
          function compileStates(states, start) {
            var all = states.$all ? toRules(states.$all) : [];
            delete states.$all;
            var keys = Object.getOwnPropertyNames(states);
            if (!start)
              start = keys[0];
            var ruleMap = /* @__PURE__ */ Object.create(null);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              ruleMap[key] = toRules(states[key]).concat(all);
            }
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              var rules = ruleMap[key];
              var included = /* @__PURE__ */ Object.create(null);
              for (var j = 0; j < rules.length; j++) {
                var rule = rules[j];
                if (!rule.include)
                  continue;
                var splice = [j, 1];
                if (rule.include !== key && !included[rule.include]) {
                  included[rule.include] = true;
                  var newRules = ruleMap[rule.include];
                  if (!newRules) {
                    throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')");
                  }
                  for (var k = 0; k < newRules.length; k++) {
                    var newRule = newRules[k];
                    if (rules.indexOf(newRule) !== -1)
                      continue;
                    splice.push(newRule);
                  }
                }
                rules.splice.apply(rules, splice);
                j--;
              }
            }
            var map = /* @__PURE__ */ Object.create(null);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              map[key] = compileRules(ruleMap[key], true);
            }
            for (var i = 0; i < keys.length; i++) {
              var name = keys[i];
              var state = map[name];
              var groups = state.groups;
              for (var j = 0; j < groups.length; j++) {
                checkStateGroup(groups[j], name, map);
              }
              var fastKeys = Object.getOwnPropertyNames(state.fast);
              for (var j = 0; j < fastKeys.length; j++) {
                checkStateGroup(state.fast[fastKeys[j]], name, map);
              }
            }
            return new Lexer(map, start);
          }
          function keywordTransform(map) {
            var isMap = typeof Map !== "undefined";
            var reverseMap = isMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
            var types = Object.getOwnPropertyNames(map);
            for (var i = 0; i < types.length; i++) {
              var tokenType = types[i];
              var item = map[tokenType];
              var keywordList = Array.isArray(item) ? item : [item];
              keywordList.forEach(function(keyword) {
                if (typeof keyword !== "string") {
                  throw new Error("keyword must be string (in keyword '" + tokenType + "')");
                }
                if (isMap) {
                  reverseMap.set(keyword, tokenType);
                } else {
                  reverseMap[keyword] = tokenType;
                }
              });
            }
            return function(k) {
              return isMap ? reverseMap.get(k) : reverseMap[k];
            };
          }
          var Lexer = function(states, state) {
            this.startState = state;
            this.states = states;
            this.buffer = "";
            this.stack = [];
            this.reset();
          };
          Lexer.prototype.reset = function(data, info) {
            this.buffer = data || "";
            this.index = 0;
            this.line = info ? info.line : 1;
            this.col = info ? info.col : 1;
            this.queuedToken = info ? info.queuedToken : null;
            this.queuedText = info ? info.queuedText : "";
            this.queuedThrow = info ? info.queuedThrow : null;
            this.setState(info ? info.state : this.startState);
            this.stack = info && info.stack ? info.stack.slice() : [];
            return this;
          };
          Lexer.prototype.save = function() {
            return {
              line: this.line,
              col: this.col,
              state: this.state,
              stack: this.stack.slice(),
              queuedToken: this.queuedToken,
              queuedText: this.queuedText,
              queuedThrow: this.queuedThrow
            };
          };
          Lexer.prototype.setState = function(state) {
            if (!state || this.state === state)
              return;
            this.state = state;
            var info = this.states[state];
            this.groups = info.groups;
            this.error = info.error;
            this.re = info.regexp;
            this.fast = info.fast;
          };
          Lexer.prototype.popState = function() {
            this.setState(this.stack.pop());
          };
          Lexer.prototype.pushState = function(state) {
            this.stack.push(this.state);
            this.setState(state);
          };
          var eat = hasSticky ? function(re, buffer) {
            return re.exec(buffer);
          } : function(re, buffer) {
            var match = re.exec(buffer);
            if (match[0].length === 0) {
              return null;
            }
            return match;
          };
          Lexer.prototype._getGroup = function(match) {
            var groupCount = this.groups.length;
            for (var i = 0; i < groupCount; i++) {
              if (match[i + 1] !== void 0) {
                return this.groups[i];
              }
            }
            throw new Error("Cannot find token type for matched text");
          };
          function tokenToString() {
            return this.value;
          }
          Lexer.prototype.next = function() {
            var index = this.index;
            if (this.queuedGroup) {
              var token = this._token(this.queuedGroup, this.queuedText, index);
              this.queuedGroup = null;
              this.queuedText = "";
              return token;
            }
            var buffer = this.buffer;
            if (index === buffer.length) {
              return;
            }
            var group = this.fast[buffer.charCodeAt(index)];
            if (group) {
              return this._token(group, buffer.charAt(index), index);
            }
            var re = this.re;
            re.lastIndex = index;
            var match = eat(re, buffer);
            var error = this.error;
            if (match == null) {
              return this._token(error, buffer.slice(index, buffer.length), index);
            }
            var group = this._getGroup(match);
            var text = match[0];
            if (error.fallback && match.index !== index) {
              this.queuedGroup = group;
              this.queuedText = text;
              return this._token(error, buffer.slice(index, match.index), index);
            }
            return this._token(group, text, index);
          };
          Lexer.prototype._token = function(group, text, offset) {
            var lineBreaks = 0;
            if (group.lineBreaks) {
              var matchNL = /\n/g;
              var nl3 = 1;
              if (text === "\n") {
                lineBreaks = 1;
              } else {
                while (matchNL.exec(text)) {
                  lineBreaks++;
                  nl3 = matchNL.lastIndex;
                }
              }
            }
            var token = {
              type: typeof group.type === "function" && group.type(text) || group.defaultType,
              value: typeof group.value === "function" ? group.value(text) : text,
              text,
              toString: tokenToString,
              offset,
              lineBreaks,
              line: this.line,
              col: this.col
            };
            var size = text.length;
            this.index += size;
            this.line += lineBreaks;
            if (lineBreaks !== 0) {
              this.col = size - nl3 + 1;
            } else {
              this.col += size;
            }
            if (group.shouldThrow) {
              var err = new Error(this.formatError(token, "invalid syntax"));
              throw err;
            }
            if (group.pop)
              this.popState();
            else if (group.push)
              this.pushState(group.push);
            else if (group.next)
              this.setState(group.next);
            return token;
          };
          if (typeof Symbol !== "undefined" && Symbol.iterator) {
            var LexerIterator = function(lexer2) {
              this.lexer = lexer2;
            };
            LexerIterator.prototype.next = function() {
              var token = this.lexer.next();
              return {
                value: token,
                done: !token
              };
            };
            LexerIterator.prototype[Symbol.iterator] = function() {
              return this;
            };
            Lexer.prototype[Symbol.iterator] = function() {
              return new LexerIterator(this);
            };
          }
          Lexer.prototype.formatError = function(token, message) {
            if (token == null) {
              var text = this.buffer.slice(this.index);
              var token = {
                text,
                offset: this.index,
                lineBreaks: text.indexOf("\n") === -1 ? 0 : 1,
                line: this.line,
                col: this.col
              };
            }
            var numLinesAround = 2;
            var firstDisplayedLine = Math.max(token.line - numLinesAround, 1);
            var lastDisplayedLine = token.line + numLinesAround;
            var lastLineDigits = String(lastDisplayedLine).length;
            var displayedLines = lastNLines(this.buffer, this.line - token.line + numLinesAround + 1).slice(0, 5);
            var errorLines = [];
            errorLines.push(message + " at line " + token.line + " col " + token.col + ":");
            errorLines.push("");
            for (var i = 0; i < displayedLines.length; i++) {
              var line = displayedLines[i];
              var lineNo = firstDisplayedLine + i;
              errorLines.push(pad(String(lineNo), lastLineDigits) + "  " + line);
              if (lineNo === token.line) {
                errorLines.push(pad("", lastLineDigits + token.col + 1) + "^");
              }
            }
            return errorLines.join("\n");
          };
          Lexer.prototype.clone = function() {
            return new Lexer(this.states, this.state);
          };
          Lexer.prototype.has = function(tokenType) {
            return true;
          };
          return {
            compile,
            states: compileStates,
            error: Object.freeze({
              error: true
            }),
            fallback: Object.freeze({
              fallback: true
            }),
            keywords: keywordTransform
          };
        });
      })(moo);
      var mooExports = moo.exports;
      (function(exports2) {
        var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : {
            "default": mod
          };
        };
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.lexer = exports2.states = void 0;
        const moo_1 = __importDefault(mooExports);
        exports2.states = {
          body: {
            doubleapos: {
              match: "''",
              value: () => "'"
            },
            quoted: {
              lineBreaks: true,
              match: /'[{}#](?:[^]*?[^'])?'(?!')/u,
              value: (src) => src.slice(1, -1).replace(/''/g, "'")
            },
            argument: {
              lineBreaks: true,
              match: /\{\s*[^\p{Pat_Syn}\p{Pat_WS}]+\s*/u,
              push: "arg",
              value: (src) => src.substring(1).trim()
            },
            octothorpe: "#",
            end: {
              match: "}",
              pop: 1
            },
            content: {
              lineBreaks: true,
              match: /[^][^{}#']*/u
            }
          },
          arg: {
            select: {
              lineBreaks: true,
              match: /,\s*(?:plural|select|selectordinal)\s*,\s*/u,
              next: "select",
              value: (src) => src.split(",")[1].trim()
            },
            "func-args": {
              lineBreaks: true,
              match: /,\s*[^\p{Pat_Syn}\p{Pat_WS}]+\s*,/u,
              next: "body",
              value: (src) => src.split(",")[1].trim()
            },
            "func-simple": {
              lineBreaks: true,
              match: /,\s*[^\p{Pat_Syn}\p{Pat_WS}]+\s*/u,
              value: (src) => src.substring(1).trim()
            },
            end: {
              match: "}",
              pop: 1
            }
          },
          select: {
            offset: {
              lineBreaks: true,
              match: /\s*offset\s*:\s*\d+\s*/u,
              value: (src) => src.split(":")[1].trim()
            },
            case: {
              lineBreaks: true,
              match: /\s*(?:=\d+|[^\p{Pat_Syn}\p{Pat_WS}]+)\s*\{/u,
              push: "body",
              value: (src) => src.substring(0, src.indexOf("{")).trim()
            },
            end: {
              match: /\s*\}/u,
              pop: 1
            }
          }
        };
        exports2.lexer = moo_1.default.states(exports2.states);
      })(lexer);
      Object.defineProperty(parser, "__esModule", {
        value: true
      });
      var parse_1 = parser.parse = parser.ParseError = void 0;
      const lexer_js_1 = lexer;
      const getContext = (lt3) => ({
        offset: lt3.offset,
        line: lt3.line,
        col: lt3.col,
        text: lt3.text,
        lineBreaks: lt3.lineBreaks
      });
      const isSelectType = (type) => type === "plural" || type === "select" || type === "selectordinal";
      function strictArgStyleParam(lt3, param) {
        let value = "";
        let text = "";
        for (const p of param) {
          const pText = p.ctx.text;
          text += pText;
          switch (p.type) {
            case "content":
              value += p.value;
              break;
            case "argument":
            case "function":
            case "octothorpe":
              value += pText;
              break;
            default:
              throw new ParseError(lt3, `Unsupported part in strict mode function arg style: ${pText}`);
          }
        }
        const c3 = {
          type: "content",
          value: value.trim(),
          ctx: Object.assign({}, param[0].ctx, {
            text
          })
        };
        return [c3];
      }
      const strictArgTypes = ["number", "date", "time", "spellout", "ordinal", "duration"];
      const defaultPluralKeys = ["zero", "one", "two", "few", "many", "other"];
      class ParseError extends Error {
        /** @internal */
        constructor(lt3, msg) {
          super(lexer_js_1.lexer.formatError(lt3, msg));
        }
      }
      parser.ParseError = ParseError;
      class Parser {
        constructor(src, opt) {
          var _a, _b, _c, _d;
          this.lexer = lexer_js_1.lexer.reset(src);
          this.cardinalKeys = (_a = opt === null || opt === void 0 ? void 0 : opt.cardinal) !== null && _a !== void 0 ? _a : defaultPluralKeys;
          this.ordinalKeys = (_b = opt === null || opt === void 0 ? void 0 : opt.ordinal) !== null && _b !== void 0 ? _b : defaultPluralKeys;
          this.strict = (_c = opt === null || opt === void 0 ? void 0 : opt.strict) !== null && _c !== void 0 ? _c : false;
          this.strictPluralKeys = (_d = opt === null || opt === void 0 ? void 0 : opt.strictPluralKeys) !== null && _d !== void 0 ? _d : true;
        }
        parse() {
          return this.parseBody(false, true);
        }
        checkSelectKey(lt3, type, key) {
          if (key[0] === "=") {
            if (type === "select")
              throw new ParseError(lt3, `The case ${key} is not valid with select`);
          } else if (type !== "select") {
            const keys = type === "plural" ? this.cardinalKeys : this.ordinalKeys;
            if (this.strictPluralKeys && keys.length > 0 && !keys.includes(key)) {
              const msg = `The ${type} case ${key} is not valid in this locale`;
              throw new ParseError(lt3, msg);
            }
          }
        }
        parseSelect(_ref, inPlural, ctx, type) {
          let {
            value: arg
          } = _ref;
          const sel = {
            type,
            arg,
            cases: [],
            ctx
          };
          if (type === "plural" || type === "selectordinal")
            inPlural = true;
          else if (this.strict)
            inPlural = false;
          for (const lt3 of this.lexer) {
            switch (lt3.type) {
              case "offset":
                if (type === "select")
                  throw new ParseError(lt3, "Unexpected plural offset for select");
                if (sel.cases.length > 0)
                  throw new ParseError(lt3, "Plural offset must be set before cases");
                sel.pluralOffset = Number(lt3.value);
                ctx.text += lt3.text;
                ctx.lineBreaks += lt3.lineBreaks;
                break;
              case "case": {
                this.checkSelectKey(lt3, type, lt3.value);
                sel.cases.push({
                  key: lt3.value,
                  tokens: this.parseBody(inPlural),
                  ctx: getContext(lt3)
                });
                break;
              }
              case "end":
                return sel;
              default:
                throw new ParseError(lt3, `Unexpected lexer token: ${lt3.type}`);
            }
          }
          throw new ParseError(null, "Unexpected message end");
        }
        parseArgToken(lt3, inPlural) {
          const ctx = getContext(lt3);
          const argType = this.lexer.next();
          if (!argType)
            throw new ParseError(null, "Unexpected message end");
          ctx.text += argType.text;
          ctx.lineBreaks += argType.lineBreaks;
          if (this.strict && (argType.type === "func-simple" || argType.type === "func-args") && !strictArgTypes.includes(argType.value)) {
            const msg = `Invalid strict mode function arg type: ${argType.value}`;
            throw new ParseError(lt3, msg);
          }
          switch (argType.type) {
            case "end":
              return {
                type: "argument",
                arg: lt3.value,
                ctx
              };
            case "func-simple": {
              const end = this.lexer.next();
              if (!end)
                throw new ParseError(null, "Unexpected message end");
              if (end.type !== "end")
                throw new ParseError(end, `Unexpected lexer token: ${end.type}`);
              ctx.text += end.text;
              if (isSelectType(argType.value.toLowerCase()))
                throw new ParseError(argType, `Invalid type identifier: ${argType.value}`);
              return {
                type: "function",
                arg: lt3.value,
                key: argType.value,
                ctx
              };
            }
            case "func-args": {
              if (isSelectType(argType.value.toLowerCase())) {
                const msg = `Invalid type identifier: ${argType.value}`;
                throw new ParseError(argType, msg);
              }
              let param = this.parseBody(this.strict ? false : inPlural);
              if (this.strict && param.length > 0)
                param = strictArgStyleParam(lt3, param);
              return {
                type: "function",
                arg: lt3.value,
                key: argType.value,
                param,
                ctx
              };
            }
            case "select":
              if (isSelectType(argType.value))
                return this.parseSelect(lt3, inPlural, ctx, argType.value);
              else
                throw new ParseError(argType, `Unexpected select type ${argType.value}`);
            default:
              throw new ParseError(argType, `Unexpected lexer token: ${argType.type}`);
          }
        }
        parseBody(inPlural, atRoot) {
          const tokens = [];
          let content = null;
          for (const lt3 of this.lexer) {
            if (lt3.type === "argument") {
              if (content)
                content = null;
              tokens.push(this.parseArgToken(lt3, inPlural));
            } else if (lt3.type === "octothorpe" && inPlural) {
              if (content)
                content = null;
              tokens.push({
                type: "octothorpe",
                ctx: getContext(lt3)
              });
            } else if (lt3.type === "end" && !atRoot) {
              return tokens;
            } else {
              let value = lt3.value;
              if (!inPlural && lt3.type === "quoted" && value[0] === "#") {
                if (value.includes("{")) {
                  const errMsg = `Unsupported escape pattern: ${value}`;
                  throw new ParseError(lt3, errMsg);
                }
                value = lt3.text;
              }
              if (content) {
                content.value += value;
                content.ctx.text += lt3.text;
                content.ctx.lineBreaks += lt3.lineBreaks;
              } else {
                content = {
                  type: "content",
                  value,
                  ctx: getContext(lt3)
                };
                tokens.push(content);
              }
            }
          }
          if (atRoot)
            return tokens;
          throw new ParseError(null, "Unexpected message end");
        }
      }
      function parse(src) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const parser2 = new Parser(src, options);
        return parser2.parse();
      }
      parse_1 = parser.parse = parse;
      function _nf$1(lc) {
        return _nf$1[lc] || (_nf$1[lc] = new Intl.NumberFormat(lc));
      }
      function number(lc, value, offset) {
        return _nf$1(lc).format(value - offset);
      }
      function strictNumber(lc, value, offset, name) {
        var n = value - offset;
        if (isNaN(n))
          throw new Error("`" + name + "` or its offset is not a number");
        return _nf$1(lc).format(n);
      }
      function plural(value, offset, lcfunc, data, isOrdinal) {
        if ({}.hasOwnProperty.call(data, value))
          return data[value];
        if (offset)
          value -= offset;
        var key = lcfunc(value, isOrdinal);
        return key in data ? data[key] : data.other;
      }
      function select(value, data) {
        return {}.hasOwnProperty.call(data, value) ? data[value] : data.other;
      }
      function reqArgs(keys, data) {
        for (var i = 0; i < keys.length; ++i)
          if (!data || data[keys[i]] === void 0)
            throw new Error("Message requires argument '".concat(keys[i], "'"));
      }
      var Runtime = Object.freeze({
        __proto__: null,
        _nf: _nf$1,
        number,
        plural,
        reqArgs,
        select,
        strictNumber
      });
      function date(value, lc, size) {
        var o2 = {
          day: "numeric",
          month: "short",
          year: "numeric"
        };
        switch (size) {
          case "full":
            o2.weekday = "long";
          case "long":
            o2.month = "long";
            break;
          case "short":
            o2.month = "numeric";
        }
        return new Date(value).toLocaleDateString(lc, o2);
      }
      function duration(value) {
        if (typeof value !== "number")
          value = Number(value);
        if (!isFinite(value))
          return String(value);
        var sign = "";
        if (value < 0) {
          sign = "-";
          value = Math.abs(value);
        } else {
          value = Number(value);
        }
        var sec = value % 60;
        var parts = [Math.round(sec) === sec ? sec : sec.toFixed(3)];
        if (value < 60) {
          parts.unshift(0);
        } else {
          value = Math.round((value - Number(parts[0])) / 60);
          parts.unshift(value % 60);
          if (value >= 60) {
            value = Math.round((value - Number(parts[0])) / 60);
            parts.unshift(value);
          }
        }
        var first = parts.shift();
        return sign + first + ":" + parts.map(function(n) {
          return Number(n) < 10 ? "0" + String(n) : String(n);
        }).join(":");
      }
      var _nf = {};
      function nf(lc, opt) {
        var key = String(lc) + JSON.stringify(opt);
        if (!_nf[key])
          _nf[key] = new Intl.NumberFormat(lc, opt);
        return _nf[key];
      }
      function numberFmt(value, lc, arg, defaultCurrency) {
        var _a = arg && arg.split(":") || [], type = _a[0], currency = _a[1];
        var opt = {
          integer: {
            maximumFractionDigits: 0
          },
          percent: {
            style: "percent"
          },
          currency: {
            style: "currency",
            currency: currency && currency.trim() || defaultCurrency,
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
          }
        };
        return nf(lc, opt[type] || {}).format(value);
      }
      var numberCurrency = function(value, lc, arg) {
        return nf(lc, {
          style: "currency",
          currency: arg,
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        }).format(value);
      };
      var numberInteger = function(value, lc) {
        return nf(lc, {
          maximumFractionDigits: 0
        }).format(value);
      };
      var numberPercent = function(value, lc) {
        return nf(lc, {
          style: "percent"
        }).format(value);
      };
      function time(value, lc, size) {
        var o2 = {
          second: "numeric",
          minute: "numeric",
          hour: "numeric"
        };
        switch (size) {
          case "full":
          case "long":
            o2.timeZoneName = "short";
            break;
          case "short":
            delete o2.second;
        }
        return new Date(value).toLocaleTimeString(lc, o2);
      }
      var Formatters = Object.freeze({
        __proto__: null,
        date,
        duration,
        numberCurrency,
        numberFmt,
        numberInteger,
        numberPercent,
        time
      });
      const ES3 = {
        break: true,
        continue: true,
        delete: true,
        else: true,
        for: true,
        function: true,
        if: true,
        in: true,
        new: true,
        return: true,
        this: true,
        typeof: true,
        var: true,
        void: true,
        while: true,
        with: true,
        case: true,
        catch: true,
        default: true,
        do: true,
        finally: true,
        instanceof: true,
        switch: true,
        throw: true,
        try: true
      };
      const ESnext = {
        // in addition to reservedES3
        await: true,
        debugger: true,
        class: true,
        enum: true,
        extends: true,
        super: true,
        const: true,
        export: true,
        import: true,
        null: true,
        true: true,
        false: true,
        implements: true,
        let: true,
        private: true,
        public: true,
        yield: true,
        interface: true,
        package: true,
        protected: true,
        static: true
      };
      var reserved = {
        ES3,
        ESnext
      };
      var reserved$1 = getDefaultExportFromCjs(reserved);
      function hashCode(str) {
        let hash = 0;
        for (let i = 0; i < str.length; ++i) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash |= 0;
        }
        return hash;
      }
      function identifier(key, unique) {
        if (unique)
          key += " " + hashCode(key).toString(36);
        const id3 = key.trim().replace(/\W+/g, "_");
        return reserved$1.ES3[id3] || reserved$1.ESnext[id3] || /^\d/.test(id3) ? "_" + id3 : id3;
      }
      function property(obj, key) {
        if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key) && !reserved$1.ES3[key]) {
          return obj ? obj + "." + key : key;
        } else {
          const jkey = JSON.stringify(key);
          return obj ? obj + "[" + jkey + "]" : jkey;
        }
      }
      var rtlLanguages = [
        "ar",
        "ckb",
        "fa",
        "he",
        "ks($|[^bfh])",
        "lrc",
        "mzn",
        "pa-Arab",
        "ps",
        "ug",
        "ur",
        "uz-Arab",
        "yi"
      ];
      var rtlRegExp = new RegExp("^" + rtlLanguages.join("|^"));
      function biDiMarkText(text, locale) {
        var isLocaleRTL = rtlRegExp.test(locale);
        var mark = JSON.stringify(isLocaleRTL ? "" : "");
        return "".concat(mark, " + ").concat(text, " + ").concat(mark);
      }
      var RUNTIME_MODULE = "@messageformat/runtime";
      var CARDINAL_MODULE = "@messageformat/runtime/lib/cardinals";
      var PLURAL_MODULE = "@messageformat/runtime/lib/plurals";
      var FORMATTER_MODULE = "@messageformat/runtime/lib/formatters";
      var Compiler = function() {
        function Compiler2(options) {
          this.arguments = [];
          this.runtime = {};
          this.options = options;
        }
        Compiler2.prototype.compile = function(src, plural2, plurals) {
          var e_1, _a;
          var _this = this;
          var _b = this.options, localeCodeFromKey = _b.localeCodeFromKey, requireAllArguments = _b.requireAllArguments, strict = _b.strict, strictPluralKeys = _b.strictPluralKeys;
          if (typeof src === "object") {
            var result = {};
            try {
              for (var _c = __values(Object.keys(src)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var key = _d.value;
                var lc = localeCodeFromKey ? localeCodeFromKey(key) : key;
                var pl3 = plurals && lc && plurals[lc] || plural2;
                result[key] = this.compile(src[key], pl3, plurals);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_d && !_d.done && (_a = _c.return))
                  _a.call(_c);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            return result;
          }
          this.plural = plural2;
          var parserOptions = {
            cardinal: plural2.cardinals,
            ordinal: plural2.ordinals,
            strict,
            strictPluralKeys
          };
          this.arguments = [];
          var r = parse_1(src, parserOptions).map(function(token) {
            return _this.token(token, null);
          });
          var hasArgs = this.arguments.length > 0;
          var res = this.concatenate(r, true);
          if (requireAllArguments && hasArgs) {
            this.setRuntimeFn("reqArgs");
            var reqArgs2 = JSON.stringify(this.arguments);
            return "(d) => { reqArgs(".concat(reqArgs2, ", d); return ").concat(res, "; }");
          }
          return "(".concat(hasArgs ? "d" : "", ") => ").concat(res);
        };
        Compiler2.prototype.cases = function(token, pluralToken) {
          var _this = this;
          var needOther = true;
          var r = token.cases.map(function(_a2) {
            var key = _a2.key, tokens = _a2.tokens;
            if (key === "other")
              needOther = false;
            var s = tokens.map(function(tok) {
              return _this.token(tok, pluralToken);
            });
            return "".concat(property(null, key.replace(/^=/, "")), ": ").concat(_this.concatenate(s, false));
          });
          if (needOther) {
            var type = token.type;
            var _a = this.plural, cardinals = _a.cardinals, ordinals = _a.ordinals;
            if (type === "select" || type === "plural" && cardinals.includes("other") || type === "selectordinal" && ordinals.includes("other"))
              throw new Error("No 'other' form found in ".concat(JSON.stringify(token)));
          }
          return "{ ".concat(r.join(", "), " }");
        };
        Compiler2.prototype.concatenate = function(tokens, root) {
          var asValues = this.options.returnType === "values";
          return asValues && (root || tokens.length > 1) ? "[" + tokens.join(", ") + "]" : tokens.join(" + ") || '""';
        };
        Compiler2.prototype.token = function(token, pluralToken) {
          if (token.type === "content")
            return JSON.stringify(token.value);
          var _a = this.plural, id3 = _a.id, lc = _a.lc;
          var args, fn;
          if ("arg" in token) {
            this.arguments.push(token.arg);
            args = [property("d", token.arg)];
          } else
            args = [];
          switch (token.type) {
            case "argument":
              return this.options.biDiSupport ? biDiMarkText(String(args[0]), lc) : String(args[0]);
            case "select":
              fn = "select";
              if (pluralToken && this.options.strict)
                pluralToken = null;
              args.push(this.cases(token, pluralToken));
              this.setRuntimeFn("select");
              break;
            case "selectordinal":
              fn = "plural";
              args.push(token.pluralOffset || 0, id3, this.cases(token, token), 1);
              this.setLocale(id3, true);
              this.setRuntimeFn("plural");
              break;
            case "plural":
              fn = "plural";
              args.push(token.pluralOffset || 0, id3, this.cases(token, token));
              this.setLocale(id3, false);
              this.setRuntimeFn("plural");
              break;
            case "function": {
              var formatter = this.options.customFormatters[token.key];
              var isModuleFn = formatter && "module" in formatter && typeof formatter.module === "function";
              if (!formatter) {
                if (token.key === "date") {
                  fn = this.setDateFormatter(token, args, pluralToken);
                  break;
                } else if (token.key === "number") {
                  fn = this.setNumberFormatter(token, args, pluralToken);
                  break;
                }
              }
              args.push(JSON.stringify(this.plural.locale));
              if (token.param) {
                if (pluralToken && this.options.strict)
                  pluralToken = null;
                var arg = this.getFormatterArg(token, pluralToken);
                if (arg)
                  args.push(arg);
              }
              fn = isModuleFn ? identifier("".concat(token.key, "__").concat(this.plural.locale)) : token.key;
              this.setFormatter(fn, token.key);
              break;
            }
            case "octothorpe":
              if (!pluralToken)
                return '"#"';
              args = [
                JSON.stringify(this.plural.locale),
                property("d", pluralToken.arg),
                pluralToken.pluralOffset || 0
              ];
              if (this.options.strict) {
                fn = "strictNumber";
                args.push(JSON.stringify(pluralToken.arg));
                this.setRuntimeFn("strictNumber");
              } else {
                fn = "number";
                this.setRuntimeFn("number");
              }
              break;
          }
          if (!fn)
            throw new Error("Parser error for token " + JSON.stringify(token));
          return "".concat(fn, "(").concat(args.join(", "), ")");
        };
        Compiler2.prototype.runtimeIncludes = function(key, type) {
          if (identifier(key) !== key)
            throw new SyntaxError("Reserved word used as ".concat(type, " identifier: ").concat(key));
          var prev = this.runtime[key];
          if (!prev || prev.type === type)
            return prev;
          throw new TypeError("Cannot override ".concat(prev.type, " runtime function as ").concat(type, ": ").concat(key));
        };
        Compiler2.prototype.setLocale = function(key, ord) {
          var prev = this.runtimeIncludes(key, "locale");
          var _a = this.plural, getCardinal = _a.getCardinal, getPlural2 = _a.getPlural, isDefault = _a.isDefault;
          var pf, module2, toString;
          if (!ord && isDefault && getCardinal) {
            if (prev)
              return;
            pf = function(n) {
              return getCardinal(n);
            };
            module2 = CARDINAL_MODULE;
            toString = function() {
              return String(getCardinal);
            };
          } else {
            if (prev && (!isDefault || prev.module === PLURAL_MODULE))
              return;
            pf = function(n, ord2) {
              return getPlural2(n, ord2);
            };
            module2 = isDefault ? PLURAL_MODULE : getPlural2.module || null;
            toString = function() {
              return String(getPlural2);
            };
          }
          this.runtime[key] = Object.assign(pf, {
            id: key,
            module: module2,
            toString,
            type: "locale"
          });
        };
        Compiler2.prototype.setRuntimeFn = function(key) {
          if (this.runtimeIncludes(key, "runtime"))
            return;
          this.runtime[key] = Object.assign(Runtime[key], {
            id: key,
            module: RUNTIME_MODULE,
            type: "runtime"
          });
        };
        Compiler2.prototype.getFormatterArg = function(_a, pluralToken) {
          var e_2, _b, e_3, _c;
          var _this = this;
          var key = _a.key, param = _a.param;
          var fmt = this.options.customFormatters[key] || isFormatterKey(key) && Formatters[key];
          if (!fmt || !param)
            return null;
          var argShape = "arg" in fmt && fmt.arg || "string";
          if (argShape === "options") {
            var value = "";
            try {
              for (var param_1 = __values(param), param_1_1 = param_1.next(); !param_1_1.done; param_1_1 = param_1.next()) {
                var tok = param_1_1.value;
                if (tok.type === "content")
                  value += tok.value;
                else
                  throw new SyntaxError("Expected literal options for ".concat(key, " formatter"));
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (param_1_1 && !param_1_1.done && (_b = param_1.return))
                  _b.call(param_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
            var options = {};
            try {
              for (var _d = __values(value.split(",")), _e = _d.next(); !_e.done; _e = _d.next()) {
                var pair = _e.value;
                var keyEnd = pair.indexOf(":");
                if (keyEnd === -1)
                  options[pair.trim()] = null;
                else {
                  var k = pair.substring(0, keyEnd).trim();
                  var v = pair.substring(keyEnd + 1).trim();
                  if (v === "true")
                    options[k] = true;
                  else if (v === "false")
                    options[k] = false;
                  else if (v === "null")
                    options[k] = null;
                  else {
                    var n = Number(v);
                    options[k] = Number.isFinite(n) ? n : v;
                  }
                }
              }
            } catch (e_3_1) {
              e_3 = { error: e_3_1 };
            } finally {
              try {
                if (_e && !_e.done && (_c = _d.return))
                  _c.call(_d);
              } finally {
                if (e_3)
                  throw e_3.error;
              }
            }
            return JSON.stringify(options);
          } else {
            var parts = param.map(function(tok2) {
              return _this.token(tok2, pluralToken);
            });
            if (argShape === "raw")
              return "[".concat(parts.join(", "), "]");
            var s = parts.join(" + ");
            return s ? "(".concat(s, ").trim()") : '""';
          }
        };
        Compiler2.prototype.setFormatter = function(key, parentKey) {
          if (this.runtimeIncludes(key, "formatter"))
            return;
          var cf = this.options.customFormatters[parentKey || key];
          if (cf) {
            var cfo_1 = typeof cf === "function" ? { formatter: cf } : cf;
            this.runtime[key] = Object.assign(cfo_1.formatter.bind({}), __assign(__assign({}, cfo_1.formatter.prototype), { toString: function() {
              return String(cfo_1.formatter);
            } }), { type: "formatter" }, "module" in cf && cf.module && cf.id ? {
              id: identifier(cf.id),
              module: typeof cf.module === "function" ? cf.module(this.plural.locale) : cf.module
            } : { id: null, module: null });
          } else if (isFormatterKey(key)) {
            this.runtime[key] = Object.assign(Formatters[key], { type: "formatter" }, { id: key, module: FORMATTER_MODULE });
          } else {
            throw new Error("Formatting function not found: ".concat(key));
          }
        };
        Compiler2.prototype.setDateFormatter = function(_a, args, plural2) {
          var _this = this;
          var param = _a.param;
          var locale = this.plural.locale;
          var argStyle = param && param.length === 1 && param[0];
          if (argStyle && argStyle.type === "content" && /^\s*::/.test(argStyle.value)) {
            var argSkeletonText_1 = argStyle.value.trim().substr(2);
            var key = identifier("date_".concat(locale, "_").concat(argSkeletonText_1), true);
            if (!this.runtimeIncludes(key, "formatter")) {
              var fmt = getDateFormatter(locale, argSkeletonText_1);
              this.runtime[key] = Object.assign(fmt, {
                id: key,
                module: null,
                toString: function() {
                  return getDateFormatterSource(locale, argSkeletonText_1);
                },
                type: "formatter"
              });
            }
            return key;
          }
          args.push(JSON.stringify(locale));
          if (param && param.length > 0) {
            if (plural2 && this.options.strict)
              plural2 = null;
            var s = param.map(function(tok) {
              return _this.token(tok, plural2);
            });
            args.push("(" + (s.join(" + ") || '""') + ").trim()");
          }
          this.setFormatter("date");
          return "date";
        };
        Compiler2.prototype.setNumberFormatter = function(_a, args, plural2) {
          var _this = this;
          var param = _a.param;
          var locale = this.plural.locale;
          if (!param || param.length === 0) {
            args.unshift(JSON.stringify(locale));
            args.push("0");
            this.setRuntimeFn("number");
            return "number";
          }
          args.push(JSON.stringify(locale));
          if (param.length === 1 && param[0].type === "content") {
            var fmtArg_1 = param[0].value.trim();
            switch (fmtArg_1) {
              case "currency":
                args.push(JSON.stringify(this.options.currency));
                this.setFormatter("numberCurrency");
                return "numberCurrency";
              case "integer":
                this.setFormatter("numberInteger");
                return "numberInteger";
              case "percent":
                this.setFormatter("numberPercent");
                return "numberPercent";
            }
            var cm = fmtArg_1.match(/^currency:([A-Z]+)$/);
            if (cm) {
              args.push(JSON.stringify(cm[1]));
              this.setFormatter("numberCurrency");
              return "numberCurrency";
            }
            var key = identifier("number_".concat(locale, "_").concat(fmtArg_1), true);
            if (!this.runtimeIncludes(key, "formatter")) {
              var currency_1 = this.options.currency;
              var fmt = getNumberFormatter(locale, fmtArg_1, currency_1);
              this.runtime[key] = Object.assign(fmt, {
                id: null,
                module: null,
                toString: function() {
                  return getNumberFormatterSource(locale, fmtArg_1, currency_1);
                },
                type: "formatter"
              });
            }
            return key;
          }
          if (plural2 && this.options.strict)
            plural2 = null;
          var s = param.map(function(tok) {
            return _this.token(tok, plural2);
          });
          args.push("(" + (s.join(" + ") || '""') + ").trim()");
          args.push(JSON.stringify(this.options.currency));
          this.setFormatter("numberFmt");
          return "numberFmt";
        };
        return Compiler2;
      }();
      function isFormatterKey(key) {
        return key in Formatters;
      }
      const a$2 = (n) => n == 1 ? "one" : "other";
      const b$2 = (n) => n == 0 || n == 1 ? "one" : "other";
      const c$2 = (n) => n >= 0 && n <= 1 ? "one" : "other";
      const d$2 = (n) => {
        const s = String(n).split("."), v0 = !s[1];
        return n == 1 && v0 ? "one" : "other";
      };
      const e$1 = (n) => "other";
      const f$2 = (n) => n == 1 ? "one" : n == 2 ? "two" : "other";
      const af$2 = a$2;
      const ak$2 = b$2;
      const am$2 = c$2;
      const an$2 = a$2;
      const ar$2 = (n) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
        return n == 0 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n100 >= 3 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 99 ? "many" : "other";
      };
      const ars$2 = (n) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
        return n == 0 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n100 >= 3 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 99 ? "many" : "other";
      };
      const as$2 = c$2;
      const asa$2 = a$2;
      const ast$2 = d$2;
      const az$2 = a$2;
      const bal$2 = a$2;
      const be$2 = (n) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
        return n10 == 1 && n100 != 11 ? "one" : n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) ? "few" : t0 && n10 == 0 || n10 >= 5 && n10 <= 9 || n100 >= 11 && n100 <= 14 ? "many" : "other";
      };
      const bem$2 = a$2;
      const bez$2 = a$2;
      const bg$2 = a$2;
      const bho$2 = b$2;
      const bm$2 = e$1;
      const bn$2 = c$2;
      const bo$2 = e$1;
      const br$2 = (n) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), n1000000 = t0 && s[0].slice(-6);
        return n10 == 1 && n100 != 11 && n100 != 71 && n100 != 91 ? "one" : n10 == 2 && n100 != 12 && n100 != 72 && n100 != 92 ? "two" : (n10 == 3 || n10 == 4 || n10 == 9) && (n100 < 10 || n100 > 19) && (n100 < 70 || n100 > 79) && (n100 < 90 || n100 > 99) ? "few" : n != 0 && t0 && n1000000 == 0 ? "many" : "other";
      };
      const brx$2 = a$2;
      const bs$2 = (n) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f3.slice(-1), f100 = f3.slice(-2);
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
      };
      const ca$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const ce$2 = a$2;
      const ceb$2 = (n) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), f10 = f3.slice(-1);
        return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? "one" : "other";
      };
      const cgg$2 = a$2;
      const chr$2 = a$2;
      const ckb$2 = a$2;
      const cs$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1];
        return n == 1 && v0 ? "one" : i >= 2 && i <= 4 && v0 ? "few" : !v0 ? "many" : "other";
      };
      const cy$2 = (n) => n == 0 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n == 3 ? "few" : n == 6 ? "many" : "other";
      const da$2 = (n) => {
        const s = String(n).split("."), i = s[0], t0 = Number(s[0]) == n;
        return n == 1 || !t0 && (i == 0 || i == 1) ? "one" : "other";
      };
      const de$2 = d$2;
      const doi$2 = c$2;
      const dsb$2 = (n) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i100 = i.slice(-2), f100 = f3.slice(-2);
        return v0 && i100 == 1 || f100 == 1 ? "one" : v0 && i100 == 2 || f100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || f100 == 3 || f100 == 4 ? "few" : "other";
      };
      const dv$2 = a$2;
      const dz$2 = e$1;
      const ee$2 = a$2;
      const el$2 = a$2;
      const en$2 = d$2;
      const eo$2 = a$2;
      const es$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        return n == 1 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const et$2 = d$2;
      const eu$2 = a$2;
      const fa$2 = c$2;
      const ff$2 = (n) => n >= 0 && n < 2 ? "one" : "other";
      const fi$2 = d$2;
      const fil$2 = (n) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), f10 = f3.slice(-1);
        return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? "one" : "other";
      };
      const fo$2 = a$2;
      const fr$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        return n >= 0 && n < 2 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const fur$2 = a$2;
      const fy$2 = d$2;
      const ga$2 = (n) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n;
        return n == 1 ? "one" : n == 2 ? "two" : t0 && n >= 3 && n <= 6 ? "few" : t0 && n >= 7 && n <= 10 ? "many" : "other";
      };
      const gd$2 = (n) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n;
        return n == 1 || n == 11 ? "one" : n == 2 || n == 12 ? "two" : t0 && n >= 3 && n <= 10 || t0 && n >= 13 && n <= 19 ? "few" : "other";
      };
      const gl$2 = d$2;
      const gsw$2 = a$2;
      const gu$2 = c$2;
      const guw$2 = b$2;
      const gv$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2);
        return v0 && i10 == 1 ? "one" : v0 && i10 == 2 ? "two" : v0 && (i100 == 0 || i100 == 20 || i100 == 40 || i100 == 60 || i100 == 80) ? "few" : !v0 ? "many" : "other";
      };
      const ha$2 = a$2;
      const haw$2 = a$2;
      const he$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1];
        return i == 1 && v0 || i == 0 && !v0 ? "one" : i == 2 && v0 ? "two" : "other";
      };
      const hi$2 = c$2;
      const hnj$2 = e$1;
      const hr$2 = (n) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f3.slice(-1), f100 = f3.slice(-2);
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
      };
      const hsb$2 = (n) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i100 = i.slice(-2), f100 = f3.slice(-2);
        return v0 && i100 == 1 || f100 == 1 ? "one" : v0 && i100 == 2 || f100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || f100 == 3 || f100 == 4 ? "few" : "other";
      };
      const hu$2 = a$2;
      const hy$2 = (n) => n >= 0 && n < 2 ? "one" : "other";
      const ia$2 = d$2;
      const id$2 = e$1;
      const ig$2 = e$1;
      const ii$2 = e$1;
      const io$2 = d$2;
      const is$2 = (n) => {
        const s = String(n).split("."), i = s[0], t2 = (s[1] || "").replace(/0+$/, ""), t0 = Number(s[0]) == n, i10 = i.slice(-1), i100 = i.slice(-2);
        return t0 && i10 == 1 && i100 != 11 || t2 % 10 == 1 && t2 % 100 != 11 ? "one" : "other";
      };
      const it$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const iu$2 = f$2;
      const ja$2 = e$1;
      const jbo$2 = e$1;
      const jgo$2 = a$2;
      const jmc$2 = a$2;
      const jv$2 = e$1;
      const jw$2 = e$1;
      const ka$2 = a$2;
      const kab$2 = (n) => n >= 0 && n < 2 ? "one" : "other";
      const kaj$2 = a$2;
      const kcg$2 = a$2;
      const kde$2 = e$1;
      const kea$2 = e$1;
      const kk$2 = a$2;
      const kkj$2 = a$2;
      const kl$2 = a$2;
      const km$2 = e$1;
      const kn$2 = c$2;
      const ko$2 = e$1;
      const ks$2 = a$2;
      const ksb$2 = a$2;
      const ksh$2 = (n) => n == 0 ? "zero" : n == 1 ? "one" : "other";
      const ku$2 = a$2;
      const kw$2 = (n) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2), n1000 = t0 && s[0].slice(-3), n100000 = t0 && s[0].slice(-5), n1000000 = t0 && s[0].slice(-6);
        return n == 0 ? "zero" : n == 1 ? "one" : n100 == 2 || n100 == 22 || n100 == 42 || n100 == 62 || n100 == 82 || t0 && n1000 == 0 && (n100000 >= 1e3 && n100000 <= 2e4 || n100000 == 4e4 || n100000 == 6e4 || n100000 == 8e4) || n != 0 && n1000000 == 1e5 ? "two" : n100 == 3 || n100 == 23 || n100 == 43 || n100 == 63 || n100 == 83 ? "few" : n != 1 && (n100 == 1 || n100 == 21 || n100 == 41 || n100 == 61 || n100 == 81) ? "many" : "other";
      };
      const ky$2 = a$2;
      const lag$2 = (n) => {
        const s = String(n).split("."), i = s[0];
        return n == 0 ? "zero" : (i == 0 || i == 1) && n != 0 ? "one" : "other";
      };
      const lb$2 = a$2;
      const lg$2 = a$2;
      const lij$2 = d$2;
      const lkt$2 = e$1;
      const ln$2 = b$2;
      const lo$2 = e$1;
      const lt$2 = (n) => {
        const s = String(n).split("."), f3 = s[1] || "", t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
        return n10 == 1 && (n100 < 11 || n100 > 19) ? "one" : n10 >= 2 && n10 <= 9 && (n100 < 11 || n100 > 19) ? "few" : f3 != 0 ? "many" : "other";
      };
      const lv$2 = (n) => {
        const s = String(n).split("."), f3 = s[1] || "", v = f3.length, t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), f100 = f3.slice(-2), f10 = f3.slice(-1);
        return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v == 2 && f100 >= 11 && f100 <= 19 ? "zero" : n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1 ? "one" : "other";
      };
      const mas$2 = a$2;
      const mg$2 = b$2;
      const mgo$2 = a$2;
      const mk$2 = (n) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f3.slice(-1), f100 = f3.slice(-2);
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : "other";
      };
      const ml$2 = a$2;
      const mn$2 = a$2;
      const mo$2 = (n) => {
        const s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
        return n == 1 && v0 ? "one" : !v0 || n == 0 || n != 1 && n100 >= 1 && n100 <= 19 ? "few" : "other";
      };
      const mr$2 = a$2;
      const ms$2 = e$1;
      const mt$2 = (n) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
        return n == 1 ? "one" : n == 2 ? "two" : n == 0 || n100 >= 3 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 19 ? "many" : "other";
      };
      const my$2 = e$1;
      const nah$2 = a$2;
      const naq$2 = f$2;
      const nb$2 = a$2;
      const nd$2 = a$2;
      const ne$2 = a$2;
      const nl$2 = d$2;
      const nn$2 = a$2;
      const nnh$2 = a$2;
      const no$2 = a$2;
      const nqo$2 = e$1;
      const nr$2 = a$2;
      const nso$2 = b$2;
      const ny$2 = a$2;
      const nyn$2 = a$2;
      const om$2 = a$2;
      const or$2 = a$2;
      const os$2 = a$2;
      const osa$2 = e$1;
      const pa$2 = b$2;
      const pap$2 = a$2;
      const pcm$2 = c$2;
      const pl$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2);
        return n == 1 && v0 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? "few" : v0 && i != 1 && (i10 == 0 || i10 == 1) || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 12 && i100 <= 14 ? "many" : "other";
      };
      const prg$2 = (n) => {
        const s = String(n).split("."), f3 = s[1] || "", v = f3.length, t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), f100 = f3.slice(-2), f10 = f3.slice(-1);
        return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v == 2 && f100 >= 11 && f100 <= 19 ? "zero" : n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1 ? "one" : "other";
      };
      const ps$2 = a$2;
      const pt$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        return i == 0 || i == 1 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const pt_PT$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const rm$2 = a$2;
      const ro$2 = (n) => {
        const s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
        return n == 1 && v0 ? "one" : !v0 || n == 0 || n != 1 && n100 >= 1 && n100 <= 19 ? "few" : "other";
      };
      const rof$2 = a$2;
      const ru$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2);
        return v0 && i10 == 1 && i100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? "few" : v0 && i10 == 0 || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 11 && i100 <= 14 ? "many" : "other";
      };
      const rwk$2 = a$2;
      const sah$2 = e$1;
      const saq$2 = a$2;
      const sat$2 = f$2;
      const sc$2 = d$2;
      const scn$2 = d$2;
      const sd$2 = a$2;
      const sdh$2 = a$2;
      const se$2 = f$2;
      const seh$2 = a$2;
      const ses$2 = e$1;
      const sg$2 = e$1;
      const sh$2 = (n) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f3.slice(-1), f100 = f3.slice(-2);
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
      };
      const shi$2 = (n) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n;
        return n >= 0 && n <= 1 ? "one" : t0 && n >= 2 && n <= 10 ? "few" : "other";
      };
      const si$2 = (n) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "";
        return n == 0 || n == 1 || i == 0 && f3 == 1 ? "one" : "other";
      };
      const sk$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1];
        return n == 1 && v0 ? "one" : i >= 2 && i <= 4 && v0 ? "few" : !v0 ? "many" : "other";
      };
      const sl$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i100 = i.slice(-2);
        return v0 && i100 == 1 ? "one" : v0 && i100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || !v0 ? "few" : "other";
      };
      const sma$2 = f$2;
      const smi$2 = f$2;
      const smj$2 = f$2;
      const smn$2 = f$2;
      const sms$2 = f$2;
      const sn$2 = a$2;
      const so$2 = a$2;
      const sq$2 = a$2;
      const sr$2 = (n) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f3.slice(-1), f100 = f3.slice(-2);
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
      };
      const ss$2 = a$2;
      const ssy$2 = a$2;
      const st$2 = a$2;
      const su$2 = e$1;
      const sv$2 = d$2;
      const sw$2 = d$2;
      const syr$2 = a$2;
      const ta$2 = a$2;
      const te$2 = a$2;
      const teo$2 = a$2;
      const th$2 = e$1;
      const ti$2 = b$2;
      const tig$2 = a$2;
      const tk$2 = a$2;
      const tl$2 = (n) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), f10 = f3.slice(-1);
        return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? "one" : "other";
      };
      const tn$2 = a$2;
      const to$2 = e$1;
      const tpi$2 = e$1;
      const tr$2 = a$2;
      const ts$2 = a$2;
      const tzm$2 = (n) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n;
        return n == 0 || n == 1 || t0 && n >= 11 && n <= 99 ? "one" : "other";
      };
      const ug$2 = a$2;
      const uk$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2);
        return v0 && i10 == 1 && i100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? "few" : v0 && i10 == 0 || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 11 && i100 <= 14 ? "many" : "other";
      };
      const und$2 = e$1;
      const ur$2 = d$2;
      const uz$2 = a$2;
      const ve$2 = a$2;
      const vec$2 = (n) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const vi$2 = e$1;
      const vo$2 = a$2;
      const vun$2 = a$2;
      const wa$2 = b$2;
      const wae$2 = a$2;
      const wo$2 = e$1;
      const xh$2 = a$2;
      const xog$2 = a$2;
      const yi$2 = d$2;
      const yo$2 = e$1;
      const yue$2 = e$1;
      const zh$2 = e$1;
      const zu$2 = c$2;
      var Cardinals = Object.freeze({
        __proto__: null,
        af: af$2,
        ak: ak$2,
        am: am$2,
        an: an$2,
        ar: ar$2,
        ars: ars$2,
        as: as$2,
        asa: asa$2,
        ast: ast$2,
        az: az$2,
        bal: bal$2,
        be: be$2,
        bem: bem$2,
        bez: bez$2,
        bg: bg$2,
        bho: bho$2,
        bm: bm$2,
        bn: bn$2,
        bo: bo$2,
        br: br$2,
        brx: brx$2,
        bs: bs$2,
        ca: ca$2,
        ce: ce$2,
        ceb: ceb$2,
        cgg: cgg$2,
        chr: chr$2,
        ckb: ckb$2,
        cs: cs$2,
        cy: cy$2,
        da: da$2,
        de: de$2,
        doi: doi$2,
        dsb: dsb$2,
        dv: dv$2,
        dz: dz$2,
        ee: ee$2,
        el: el$2,
        en: en$2,
        eo: eo$2,
        es: es$2,
        et: et$2,
        eu: eu$2,
        fa: fa$2,
        ff: ff$2,
        fi: fi$2,
        fil: fil$2,
        fo: fo$2,
        fr: fr$2,
        fur: fur$2,
        fy: fy$2,
        ga: ga$2,
        gd: gd$2,
        gl: gl$2,
        gsw: gsw$2,
        gu: gu$2,
        guw: guw$2,
        gv: gv$2,
        ha: ha$2,
        haw: haw$2,
        he: he$2,
        hi: hi$2,
        hnj: hnj$2,
        hr: hr$2,
        hsb: hsb$2,
        hu: hu$2,
        hy: hy$2,
        ia: ia$2,
        id: id$2,
        ig: ig$2,
        ii: ii$2,
        io: io$2,
        is: is$2,
        it: it$2,
        iu: iu$2,
        ja: ja$2,
        jbo: jbo$2,
        jgo: jgo$2,
        jmc: jmc$2,
        jv: jv$2,
        jw: jw$2,
        ka: ka$2,
        kab: kab$2,
        kaj: kaj$2,
        kcg: kcg$2,
        kde: kde$2,
        kea: kea$2,
        kk: kk$2,
        kkj: kkj$2,
        kl: kl$2,
        km: km$2,
        kn: kn$2,
        ko: ko$2,
        ks: ks$2,
        ksb: ksb$2,
        ksh: ksh$2,
        ku: ku$2,
        kw: kw$2,
        ky: ky$2,
        lag: lag$2,
        lb: lb$2,
        lg: lg$2,
        lij: lij$2,
        lkt: lkt$2,
        ln: ln$2,
        lo: lo$2,
        lt: lt$2,
        lv: lv$2,
        mas: mas$2,
        mg: mg$2,
        mgo: mgo$2,
        mk: mk$2,
        ml: ml$2,
        mn: mn$2,
        mo: mo$2,
        mr: mr$2,
        ms: ms$2,
        mt: mt$2,
        my: my$2,
        nah: nah$2,
        naq: naq$2,
        nb: nb$2,
        nd: nd$2,
        ne: ne$2,
        nl: nl$2,
        nn: nn$2,
        nnh: nnh$2,
        no: no$2,
        nqo: nqo$2,
        nr: nr$2,
        nso: nso$2,
        ny: ny$2,
        nyn: nyn$2,
        om: om$2,
        or: or$2,
        os: os$2,
        osa: osa$2,
        pa: pa$2,
        pap: pap$2,
        pcm: pcm$2,
        pl: pl$2,
        prg: prg$2,
        ps: ps$2,
        pt: pt$2,
        pt_PT: pt_PT$2,
        rm: rm$2,
        ro: ro$2,
        rof: rof$2,
        ru: ru$2,
        rwk: rwk$2,
        sah: sah$2,
        saq: saq$2,
        sat: sat$2,
        sc: sc$2,
        scn: scn$2,
        sd: sd$2,
        sdh: sdh$2,
        se: se$2,
        seh: seh$2,
        ses: ses$2,
        sg: sg$2,
        sh: sh$2,
        shi: shi$2,
        si: si$2,
        sk: sk$2,
        sl: sl$2,
        sma: sma$2,
        smi: smi$2,
        smj: smj$2,
        smn: smn$2,
        sms: sms$2,
        sn: sn$2,
        so: so$2,
        sq: sq$2,
        sr: sr$2,
        ss: ss$2,
        ssy: ssy$2,
        st: st$2,
        su: su$2,
        sv: sv$2,
        sw: sw$2,
        syr: syr$2,
        ta: ta$2,
        te: te$2,
        teo: teo$2,
        th: th$2,
        ti: ti$2,
        tig: tig$2,
        tk: tk$2,
        tl: tl$2,
        tn: tn$2,
        to: to$2,
        tpi: tpi$2,
        tr: tr$2,
        ts: ts$2,
        tzm: tzm$2,
        ug: ug$2,
        uk: uk$2,
        und: und$2,
        ur: ur$2,
        uz: uz$2,
        ve: ve$2,
        vec: vec$2,
        vi: vi$2,
        vo: vo$2,
        vun: vun$2,
        wa: wa$2,
        wae: wae$2,
        wo: wo$2,
        xh: xh$2,
        xog: xog$2,
        yi: yi$2,
        yo: yo$2,
        yue: yue$2,
        zh: zh$2,
        zu: zu$2
      });
      const z = "zero", o = "one", t = "two", f$1 = "few", m = "many", x = "other";
      const a$1 = {
        cardinal: [o, x],
        ordinal: [x]
      };
      const b$1 = {
        cardinal: [o, x],
        ordinal: [o, x]
      };
      const c$1 = {
        cardinal: [x],
        ordinal: [x]
      };
      const d$1 = {
        cardinal: [o, t, x],
        ordinal: [x]
      };
      const af$1 = a$1;
      const ak$1 = a$1;
      const am$1 = a$1;
      const an$1 = a$1;
      const ar$1 = {
        cardinal: [z, o, t, f$1, m, x],
        ordinal: [x]
      };
      const ars$1 = {
        cardinal: [z, o, t, f$1, m, x],
        ordinal: [x]
      };
      const as$1 = {
        cardinal: [o, x],
        ordinal: [o, t, f$1, m, x]
      };
      const asa$1 = a$1;
      const ast$1 = a$1;
      const az$1 = {
        cardinal: [o, x],
        ordinal: [o, f$1, m, x]
      };
      const bal$1 = b$1;
      const be$1 = {
        cardinal: [o, f$1, m, x],
        ordinal: [f$1, x]
      };
      const bem$1 = a$1;
      const bez$1 = a$1;
      const bg$1 = a$1;
      const bho$1 = a$1;
      const bm$1 = c$1;
      const bn$1 = {
        cardinal: [o, x],
        ordinal: [o, t, f$1, m, x]
      };
      const bo$1 = c$1;
      const br$1 = {
        cardinal: [o, t, f$1, m, x],
        ordinal: [x]
      };
      const brx$1 = a$1;
      const bs$1 = {
        cardinal: [o, f$1, x],
        ordinal: [x]
      };
      const ca$1 = {
        cardinal: [o, m, x],
        ordinal: [o, t, f$1, x]
      };
      const ce$1 = a$1;
      const ceb$1 = a$1;
      const cgg$1 = a$1;
      const chr$1 = a$1;
      const ckb$1 = a$1;
      const cs$1 = {
        cardinal: [o, f$1, m, x],
        ordinal: [x]
      };
      const cy$1 = {
        cardinal: [z, o, t, f$1, m, x],
        ordinal: [z, o, t, f$1, m, x]
      };
      const da$1 = a$1;
      const de$1 = a$1;
      const doi$1 = a$1;
      const dsb$1 = {
        cardinal: [o, t, f$1, x],
        ordinal: [x]
      };
      const dv$1 = a$1;
      const dz$1 = c$1;
      const ee$1 = a$1;
      const el$1 = a$1;
      const en$1 = {
        cardinal: [o, x],
        ordinal: [o, t, f$1, x]
      };
      const eo$1 = a$1;
      const es$1 = {
        cardinal: [o, m, x],
        ordinal: [x]
      };
      const et$1 = a$1;
      const eu$1 = a$1;
      const fa$1 = a$1;
      const ff$1 = a$1;
      const fi$1 = a$1;
      const fil$1 = b$1;
      const fo$1 = a$1;
      const fr$1 = {
        cardinal: [o, m, x],
        ordinal: [o, x]
      };
      const fur$1 = a$1;
      const fy$1 = a$1;
      const ga$1 = {
        cardinal: [o, t, f$1, m, x],
        ordinal: [o, x]
      };
      const gd$1 = {
        cardinal: [o, t, f$1, x],
        ordinal: [o, t, f$1, x]
      };
      const gl$1 = a$1;
      const gsw$1 = a$1;
      const gu$1 = {
        cardinal: [o, x],
        ordinal: [o, t, f$1, m, x]
      };
      const guw$1 = a$1;
      const gv$1 = {
        cardinal: [o, t, f$1, m, x],
        ordinal: [x]
      };
      const ha$1 = a$1;
      const haw$1 = a$1;
      const he$1 = d$1;
      const hi$1 = {
        cardinal: [o, x],
        ordinal: [o, t, f$1, m, x]
      };
      const hnj$1 = c$1;
      const hr$1 = {
        cardinal: [o, f$1, x],
        ordinal: [x]
      };
      const hsb$1 = {
        cardinal: [o, t, f$1, x],
        ordinal: [x]
      };
      const hu$1 = b$1;
      const hy$1 = b$1;
      const ia$1 = a$1;
      const id$1 = c$1;
      const ig$1 = c$1;
      const ii$1 = c$1;
      const io$1 = a$1;
      const is$1 = a$1;
      const it$1 = {
        cardinal: [o, m, x],
        ordinal: [m, x]
      };
      const iu$1 = d$1;
      const ja$1 = c$1;
      const jbo$1 = c$1;
      const jgo$1 = a$1;
      const jmc$1 = a$1;
      const jv$1 = c$1;
      const jw$1 = c$1;
      const ka$1 = {
        cardinal: [o, x],
        ordinal: [o, m, x]
      };
      const kab$1 = a$1;
      const kaj$1 = a$1;
      const kcg$1 = a$1;
      const kde$1 = c$1;
      const kea$1 = c$1;
      const kk$1 = {
        cardinal: [o, x],
        ordinal: [m, x]
      };
      const kkj$1 = a$1;
      const kl$1 = a$1;
      const km$1 = c$1;
      const kn$1 = a$1;
      const ko$1 = c$1;
      const ks$1 = a$1;
      const ksb$1 = a$1;
      const ksh$1 = {
        cardinal: [z, o, x],
        ordinal: [x]
      };
      const ku$1 = a$1;
      const kw$1 = {
        cardinal: [z, o, t, f$1, m, x],
        ordinal: [o, m, x]
      };
      const ky$1 = a$1;
      const lag$1 = {
        cardinal: [z, o, x],
        ordinal: [x]
      };
      const lb$1 = a$1;
      const lg$1 = a$1;
      const lij$1 = {
        cardinal: [o, x],
        ordinal: [m, x]
      };
      const lkt$1 = c$1;
      const ln$1 = a$1;
      const lo$1 = {
        cardinal: [x],
        ordinal: [o, x]
      };
      const lt$1 = {
        cardinal: [o, f$1, m, x],
        ordinal: [x]
      };
      const lv$1 = {
        cardinal: [z, o, x],
        ordinal: [x]
      };
      const mas$1 = a$1;
      const mg$1 = a$1;
      const mgo$1 = a$1;
      const mk$1 = {
        cardinal: [o, x],
        ordinal: [o, t, m, x]
      };
      const ml$1 = a$1;
      const mn$1 = a$1;
      const mo$1 = {
        cardinal: [o, f$1, x],
        ordinal: [o, x]
      };
      const mr$1 = {
        cardinal: [o, x],
        ordinal: [o, t, f$1, x]
      };
      const ms$1 = {
        cardinal: [x],
        ordinal: [o, x]
      };
      const mt$1 = {
        cardinal: [o, t, f$1, m, x],
        ordinal: [x]
      };
      const my$1 = c$1;
      const nah$1 = a$1;
      const naq$1 = d$1;
      const nb$1 = a$1;
      const nd$1 = a$1;
      const ne$1 = b$1;
      const nl$1 = a$1;
      const nn$1 = a$1;
      const nnh$1 = a$1;
      const no$1 = a$1;
      const nqo$1 = c$1;
      const nr$1 = a$1;
      const nso$1 = a$1;
      const ny$1 = a$1;
      const nyn$1 = a$1;
      const om$1 = a$1;
      const or$1 = {
        cardinal: [o, x],
        ordinal: [o, t, f$1, m, x]
      };
      const os$1 = a$1;
      const osa$1 = c$1;
      const pa$1 = a$1;
      const pap$1 = a$1;
      const pcm$1 = a$1;
      const pl$1 = {
        cardinal: [o, f$1, m, x],
        ordinal: [x]
      };
      const prg$1 = {
        cardinal: [z, o, x],
        ordinal: [x]
      };
      const ps$1 = a$1;
      const pt$1 = {
        cardinal: [o, m, x],
        ordinal: [x]
      };
      const pt_PT$1 = {
        cardinal: [o, m, x],
        ordinal: [x]
      };
      const rm$1 = a$1;
      const ro$1 = {
        cardinal: [o, f$1, x],
        ordinal: [o, x]
      };
      const rof$1 = a$1;
      const ru$1 = {
        cardinal: [o, f$1, m, x],
        ordinal: [x]
      };
      const rwk$1 = a$1;
      const sah$1 = c$1;
      const saq$1 = a$1;
      const sat$1 = d$1;
      const sc$1 = {
        cardinal: [o, x],
        ordinal: [m, x]
      };
      const scn$1 = {
        cardinal: [o, x],
        ordinal: [m, x]
      };
      const sd$1 = a$1;
      const sdh$1 = a$1;
      const se$1 = d$1;
      const seh$1 = a$1;
      const ses$1 = c$1;
      const sg$1 = c$1;
      const sh$1 = {
        cardinal: [o, f$1, x],
        ordinal: [x]
      };
      const shi$1 = {
        cardinal: [o, f$1, x],
        ordinal: [x]
      };
      const si$1 = a$1;
      const sk$1 = {
        cardinal: [o, f$1, m, x],
        ordinal: [x]
      };
      const sl$1 = {
        cardinal: [o, t, f$1, x],
        ordinal: [x]
      };
      const sma$1 = d$1;
      const smi$1 = d$1;
      const smj$1 = d$1;
      const smn$1 = d$1;
      const sms$1 = d$1;
      const sn$1 = a$1;
      const so$1 = a$1;
      const sq$1 = {
        cardinal: [o, x],
        ordinal: [o, m, x]
      };
      const sr$1 = {
        cardinal: [o, f$1, x],
        ordinal: [x]
      };
      const ss$1 = a$1;
      const ssy$1 = a$1;
      const st$1 = a$1;
      const su$1 = c$1;
      const sv$1 = b$1;
      const sw$1 = a$1;
      const syr$1 = a$1;
      const ta$1 = a$1;
      const te$1 = a$1;
      const teo$1 = a$1;
      const th$1 = c$1;
      const ti$1 = a$1;
      const tig$1 = a$1;
      const tk$1 = {
        cardinal: [o, x],
        ordinal: [f$1, x]
      };
      const tl$1 = b$1;
      const tn$1 = a$1;
      const to$1 = c$1;
      const tpi$1 = c$1;
      const tr$1 = a$1;
      const ts$1 = a$1;
      const tzm$1 = a$1;
      const ug$1 = a$1;
      const uk$1 = {
        cardinal: [o, f$1, m, x],
        ordinal: [f$1, x]
      };
      const und$1 = c$1;
      const ur$1 = a$1;
      const uz$1 = a$1;
      const ve$1 = a$1;
      const vec$1 = {
        cardinal: [o, m, x],
        ordinal: [m, x]
      };
      const vi$1 = {
        cardinal: [x],
        ordinal: [o, x]
      };
      const vo$1 = a$1;
      const vun$1 = a$1;
      const wa$1 = a$1;
      const wae$1 = a$1;
      const wo$1 = c$1;
      const xh$1 = a$1;
      const xog$1 = a$1;
      const yi$1 = a$1;
      const yo$1 = c$1;
      const yue$1 = c$1;
      const zh$1 = c$1;
      const zu$1 = a$1;
      var PluralCategories = Object.freeze({
        __proto__: null,
        af: af$1,
        ak: ak$1,
        am: am$1,
        an: an$1,
        ar: ar$1,
        ars: ars$1,
        as: as$1,
        asa: asa$1,
        ast: ast$1,
        az: az$1,
        bal: bal$1,
        be: be$1,
        bem: bem$1,
        bez: bez$1,
        bg: bg$1,
        bho: bho$1,
        bm: bm$1,
        bn: bn$1,
        bo: bo$1,
        br: br$1,
        brx: brx$1,
        bs: bs$1,
        ca: ca$1,
        ce: ce$1,
        ceb: ceb$1,
        cgg: cgg$1,
        chr: chr$1,
        ckb: ckb$1,
        cs: cs$1,
        cy: cy$1,
        da: da$1,
        de: de$1,
        doi: doi$1,
        dsb: dsb$1,
        dv: dv$1,
        dz: dz$1,
        ee: ee$1,
        el: el$1,
        en: en$1,
        eo: eo$1,
        es: es$1,
        et: et$1,
        eu: eu$1,
        fa: fa$1,
        ff: ff$1,
        fi: fi$1,
        fil: fil$1,
        fo: fo$1,
        fr: fr$1,
        fur: fur$1,
        fy: fy$1,
        ga: ga$1,
        gd: gd$1,
        gl: gl$1,
        gsw: gsw$1,
        gu: gu$1,
        guw: guw$1,
        gv: gv$1,
        ha: ha$1,
        haw: haw$1,
        he: he$1,
        hi: hi$1,
        hnj: hnj$1,
        hr: hr$1,
        hsb: hsb$1,
        hu: hu$1,
        hy: hy$1,
        ia: ia$1,
        id: id$1,
        ig: ig$1,
        ii: ii$1,
        io: io$1,
        is: is$1,
        it: it$1,
        iu: iu$1,
        ja: ja$1,
        jbo: jbo$1,
        jgo: jgo$1,
        jmc: jmc$1,
        jv: jv$1,
        jw: jw$1,
        ka: ka$1,
        kab: kab$1,
        kaj: kaj$1,
        kcg: kcg$1,
        kde: kde$1,
        kea: kea$1,
        kk: kk$1,
        kkj: kkj$1,
        kl: kl$1,
        km: km$1,
        kn: kn$1,
        ko: ko$1,
        ks: ks$1,
        ksb: ksb$1,
        ksh: ksh$1,
        ku: ku$1,
        kw: kw$1,
        ky: ky$1,
        lag: lag$1,
        lb: lb$1,
        lg: lg$1,
        lij: lij$1,
        lkt: lkt$1,
        ln: ln$1,
        lo: lo$1,
        lt: lt$1,
        lv: lv$1,
        mas: mas$1,
        mg: mg$1,
        mgo: mgo$1,
        mk: mk$1,
        ml: ml$1,
        mn: mn$1,
        mo: mo$1,
        mr: mr$1,
        ms: ms$1,
        mt: mt$1,
        my: my$1,
        nah: nah$1,
        naq: naq$1,
        nb: nb$1,
        nd: nd$1,
        ne: ne$1,
        nl: nl$1,
        nn: nn$1,
        nnh: nnh$1,
        no: no$1,
        nqo: nqo$1,
        nr: nr$1,
        nso: nso$1,
        ny: ny$1,
        nyn: nyn$1,
        om: om$1,
        or: or$1,
        os: os$1,
        osa: osa$1,
        pa: pa$1,
        pap: pap$1,
        pcm: pcm$1,
        pl: pl$1,
        prg: prg$1,
        ps: ps$1,
        pt: pt$1,
        pt_PT: pt_PT$1,
        rm: rm$1,
        ro: ro$1,
        rof: rof$1,
        ru: ru$1,
        rwk: rwk$1,
        sah: sah$1,
        saq: saq$1,
        sat: sat$1,
        sc: sc$1,
        scn: scn$1,
        sd: sd$1,
        sdh: sdh$1,
        se: se$1,
        seh: seh$1,
        ses: ses$1,
        sg: sg$1,
        sh: sh$1,
        shi: shi$1,
        si: si$1,
        sk: sk$1,
        sl: sl$1,
        sma: sma$1,
        smi: smi$1,
        smj: smj$1,
        smn: smn$1,
        sms: sms$1,
        sn: sn$1,
        so: so$1,
        sq: sq$1,
        sr: sr$1,
        ss: ss$1,
        ssy: ssy$1,
        st: st$1,
        su: su$1,
        sv: sv$1,
        sw: sw$1,
        syr: syr$1,
        ta: ta$1,
        te: te$1,
        teo: teo$1,
        th: th$1,
        ti: ti$1,
        tig: tig$1,
        tk: tk$1,
        tl: tl$1,
        tn: tn$1,
        to: to$1,
        tpi: tpi$1,
        tr: tr$1,
        ts: ts$1,
        tzm: tzm$1,
        ug: ug$1,
        uk: uk$1,
        und: und$1,
        ur: ur$1,
        uz: uz$1,
        ve: ve$1,
        vec: vec$1,
        vi: vi$1,
        vo: vo$1,
        vun: vun$1,
        wa: wa$1,
        wae: wae$1,
        wo: wo$1,
        xh: xh$1,
        xog: xog$1,
        yi: yi$1,
        yo: yo$1,
        yue: yue$1,
        zh: zh$1,
        zu: zu$1
      });
      const a2 = (n, ord) => {
        if (ord)
          return "other";
        return n == 1 ? "one" : "other";
      };
      const b2 = (n, ord) => {
        if (ord)
          return "other";
        return n == 0 || n == 1 ? "one" : "other";
      };
      const c2 = (n, ord) => {
        if (ord)
          return "other";
        return n >= 0 && n <= 1 ? "one" : "other";
      };
      const d2 = (n, ord) => {
        const s = String(n).split("."), v0 = !s[1];
        if (ord)
          return "other";
        return n == 1 && v0 ? "one" : "other";
      };
      const e2 = (n, ord) => "other";
      const f2 = (n, ord) => {
        if (ord)
          return "other";
        return n == 1 ? "one" : n == 2 ? "two" : "other";
      };
      const af2 = a2;
      const ak2 = b2;
      const am2 = c2;
      const an2 = a2;
      const ar2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
        if (ord)
          return "other";
        return n == 0 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n100 >= 3 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 99 ? "many" : "other";
      };
      const ars2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
        if (ord)
          return "other";
        return n == 0 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n100 >= 3 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 99 ? "many" : "other";
      };
      const as2 = (n, ord) => {
        if (ord)
          return n == 1 || n == 5 || n == 7 || n == 8 || n == 9 || n == 10 ? "one" : n == 2 || n == 3 ? "two" : n == 4 ? "few" : n == 6 ? "many" : "other";
        return n >= 0 && n <= 1 ? "one" : "other";
      };
      const asa2 = a2;
      const ast2 = d2;
      const az2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], i10 = i.slice(-1), i100 = i.slice(-2), i1000 = i.slice(-3);
        if (ord)
          return i10 == 1 || i10 == 2 || i10 == 5 || i10 == 7 || i10 == 8 || i100 == 20 || i100 == 50 || i100 == 70 || i100 == 80 ? "one" : i10 == 3 || i10 == 4 || i1000 == 100 || i1000 == 200 || i1000 == 300 || i1000 == 400 || i1000 == 500 || i1000 == 600 || i1000 == 700 || i1000 == 800 || i1000 == 900 ? "few" : i == 0 || i10 == 6 || i100 == 40 || i100 == 60 || i100 == 90 ? "many" : "other";
        return n == 1 ? "one" : "other";
      };
      const bal2 = (n, ord) => n == 1 ? "one" : "other";
      const be2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
        if (ord)
          return (n10 == 2 || n10 == 3) && n100 != 12 && n100 != 13 ? "few" : "other";
        return n10 == 1 && n100 != 11 ? "one" : n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) ? "few" : t0 && n10 == 0 || n10 >= 5 && n10 <= 9 || n100 >= 11 && n100 <= 14 ? "many" : "other";
      };
      const bem2 = a2;
      const bez2 = a2;
      const bg2 = a2;
      const bho2 = b2;
      const bm2 = e2;
      const bn2 = (n, ord) => {
        if (ord)
          return n == 1 || n == 5 || n == 7 || n == 8 || n == 9 || n == 10 ? "one" : n == 2 || n == 3 ? "two" : n == 4 ? "few" : n == 6 ? "many" : "other";
        return n >= 0 && n <= 1 ? "one" : "other";
      };
      const bo2 = e2;
      const br2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), n1000000 = t0 && s[0].slice(-6);
        if (ord)
          return "other";
        return n10 == 1 && n100 != 11 && n100 != 71 && n100 != 91 ? "one" : n10 == 2 && n100 != 12 && n100 != 72 && n100 != 92 ? "two" : (n10 == 3 || n10 == 4 || n10 == 9) && (n100 < 10 || n100 > 19) && (n100 < 70 || n100 > 79) && (n100 < 90 || n100 > 99) ? "few" : n != 0 && t0 && n1000000 == 0 ? "many" : "other";
      };
      const brx2 = a2;
      const bs2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f3.slice(-1), f100 = f3.slice(-2);
        if (ord)
          return "other";
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
      };
      const ca2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        if (ord)
          return n == 1 || n == 3 ? "one" : n == 2 ? "two" : n == 4 ? "few" : "other";
        return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const ce2 = a2;
      const ceb2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), f10 = f3.slice(-1);
        if (ord)
          return "other";
        return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? "one" : "other";
      };
      const cgg2 = a2;
      const chr2 = a2;
      const ckb2 = a2;
      const cs2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1];
        if (ord)
          return "other";
        return n == 1 && v0 ? "one" : i >= 2 && i <= 4 && v0 ? "few" : !v0 ? "many" : "other";
      };
      const cy2 = (n, ord) => {
        if (ord)
          return n == 0 || n == 7 || n == 8 || n == 9 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n == 3 || n == 4 ? "few" : n == 5 || n == 6 ? "many" : "other";
        return n == 0 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n == 3 ? "few" : n == 6 ? "many" : "other";
      };
      const da2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], t0 = Number(s[0]) == n;
        if (ord)
          return "other";
        return n == 1 || !t0 && (i == 0 || i == 1) ? "one" : "other";
      };
      const de2 = d2;
      const doi2 = c2;
      const dsb2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i100 = i.slice(-2), f100 = f3.slice(-2);
        if (ord)
          return "other";
        return v0 && i100 == 1 || f100 == 1 ? "one" : v0 && i100 == 2 || f100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || f100 == 3 || f100 == 4 ? "few" : "other";
      };
      const dv2 = a2;
      const dz2 = e2;
      const ee2 = a2;
      const el2 = a2;
      const en2 = (n, ord) => {
        const s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
        if (ord)
          return n10 == 1 && n100 != 11 ? "one" : n10 == 2 && n100 != 12 ? "two" : n10 == 3 && n100 != 13 ? "few" : "other";
        return n == 1 && v0 ? "one" : "other";
      };
      const eo2 = a2;
      const es2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        if (ord)
          return "other";
        return n == 1 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const et2 = d2;
      const eu2 = a2;
      const fa2 = c2;
      const ff2 = (n, ord) => {
        if (ord)
          return "other";
        return n >= 0 && n < 2 ? "one" : "other";
      };
      const fi2 = d2;
      const fil2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), f10 = f3.slice(-1);
        if (ord)
          return n == 1 ? "one" : "other";
        return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? "one" : "other";
      };
      const fo2 = a2;
      const fr2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        if (ord)
          return n == 1 ? "one" : "other";
        return n >= 0 && n < 2 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const fur2 = a2;
      const fy2 = d2;
      const ga2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n;
        if (ord)
          return n == 1 ? "one" : "other";
        return n == 1 ? "one" : n == 2 ? "two" : t0 && n >= 3 && n <= 6 ? "few" : t0 && n >= 7 && n <= 10 ? "many" : "other";
      };
      const gd2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n;
        if (ord)
          return n == 1 || n == 11 ? "one" : n == 2 || n == 12 ? "two" : n == 3 || n == 13 ? "few" : "other";
        return n == 1 || n == 11 ? "one" : n == 2 || n == 12 ? "two" : t0 && n >= 3 && n <= 10 || t0 && n >= 13 && n <= 19 ? "few" : "other";
      };
      const gl2 = d2;
      const gsw2 = a2;
      const gu2 = (n, ord) => {
        if (ord)
          return n == 1 ? "one" : n == 2 || n == 3 ? "two" : n == 4 ? "few" : n == 6 ? "many" : "other";
        return n >= 0 && n <= 1 ? "one" : "other";
      };
      const guw2 = b2;
      const gv2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2);
        if (ord)
          return "other";
        return v0 && i10 == 1 ? "one" : v0 && i10 == 2 ? "two" : v0 && (i100 == 0 || i100 == 20 || i100 == 40 || i100 == 60 || i100 == 80) ? "few" : !v0 ? "many" : "other";
      };
      const ha2 = a2;
      const haw2 = a2;
      const he2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1];
        if (ord)
          return "other";
        return i == 1 && v0 || i == 0 && !v0 ? "one" : i == 2 && v0 ? "two" : "other";
      };
      const hi2 = (n, ord) => {
        if (ord)
          return n == 1 ? "one" : n == 2 || n == 3 ? "two" : n == 4 ? "few" : n == 6 ? "many" : "other";
        return n >= 0 && n <= 1 ? "one" : "other";
      };
      const hnj2 = e2;
      const hr2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f3.slice(-1), f100 = f3.slice(-2);
        if (ord)
          return "other";
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
      };
      const hsb2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i100 = i.slice(-2), f100 = f3.slice(-2);
        if (ord)
          return "other";
        return v0 && i100 == 1 || f100 == 1 ? "one" : v0 && i100 == 2 || f100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || f100 == 3 || f100 == 4 ? "few" : "other";
      };
      const hu2 = (n, ord) => {
        if (ord)
          return n == 1 || n == 5 ? "one" : "other";
        return n == 1 ? "one" : "other";
      };
      const hy2 = (n, ord) => {
        if (ord)
          return n == 1 ? "one" : "other";
        return n >= 0 && n < 2 ? "one" : "other";
      };
      const ia2 = d2;
      const id2 = e2;
      const ig2 = e2;
      const ii2 = e2;
      const io2 = d2;
      const is2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], t2 = (s[1] || "").replace(/0+$/, ""), t0 = Number(s[0]) == n, i10 = i.slice(-1), i100 = i.slice(-2);
        if (ord)
          return "other";
        return t0 && i10 == 1 && i100 != 11 || t2 % 10 == 1 && t2 % 100 != 11 ? "one" : "other";
      };
      const it2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        if (ord)
          return n == 11 || n == 8 || n == 80 || n == 800 ? "many" : "other";
        return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const iu2 = f2;
      const ja2 = e2;
      const jbo2 = e2;
      const jgo2 = a2;
      const jmc2 = a2;
      const jv2 = e2;
      const jw2 = e2;
      const ka2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], i100 = i.slice(-2);
        if (ord)
          return i == 1 ? "one" : i == 0 || i100 >= 2 && i100 <= 20 || i100 == 40 || i100 == 60 || i100 == 80 ? "many" : "other";
        return n == 1 ? "one" : "other";
      };
      const kab2 = (n, ord) => {
        if (ord)
          return "other";
        return n >= 0 && n < 2 ? "one" : "other";
      };
      const kaj2 = a2;
      const kcg2 = a2;
      const kde2 = e2;
      const kea2 = e2;
      const kk2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1);
        if (ord)
          return n10 == 6 || n10 == 9 || t0 && n10 == 0 && n != 0 ? "many" : "other";
        return n == 1 ? "one" : "other";
      };
      const kkj2 = a2;
      const kl2 = a2;
      const km2 = e2;
      const kn2 = c2;
      const ko2 = e2;
      const ks2 = a2;
      const ksb2 = a2;
      const ksh2 = (n, ord) => {
        if (ord)
          return "other";
        return n == 0 ? "zero" : n == 1 ? "one" : "other";
      };
      const ku2 = a2;
      const kw2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2), n1000 = t0 && s[0].slice(-3), n100000 = t0 && s[0].slice(-5), n1000000 = t0 && s[0].slice(-6);
        if (ord)
          return t0 && n >= 1 && n <= 4 || n100 >= 1 && n100 <= 4 || n100 >= 21 && n100 <= 24 || n100 >= 41 && n100 <= 44 || n100 >= 61 && n100 <= 64 || n100 >= 81 && n100 <= 84 ? "one" : n == 5 || n100 == 5 ? "many" : "other";
        return n == 0 ? "zero" : n == 1 ? "one" : n100 == 2 || n100 == 22 || n100 == 42 || n100 == 62 || n100 == 82 || t0 && n1000 == 0 && (n100000 >= 1e3 && n100000 <= 2e4 || n100000 == 4e4 || n100000 == 6e4 || n100000 == 8e4) || n != 0 && n1000000 == 1e5 ? "two" : n100 == 3 || n100 == 23 || n100 == 43 || n100 == 63 || n100 == 83 ? "few" : n != 1 && (n100 == 1 || n100 == 21 || n100 == 41 || n100 == 61 || n100 == 81) ? "many" : "other";
      };
      const ky2 = a2;
      const lag2 = (n, ord) => {
        const s = String(n).split("."), i = s[0];
        if (ord)
          return "other";
        return n == 0 ? "zero" : (i == 0 || i == 1) && n != 0 ? "one" : "other";
      };
      const lb2 = a2;
      const lg2 = a2;
      const lij2 = (n, ord) => {
        const s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n;
        if (ord)
          return n == 11 || n == 8 || t0 && n >= 80 && n <= 89 || t0 && n >= 800 && n <= 899 ? "many" : "other";
        return n == 1 && v0 ? "one" : "other";
      };
      const lkt2 = e2;
      const ln2 = b2;
      const lo2 = (n, ord) => {
        if (ord)
          return n == 1 ? "one" : "other";
        return "other";
      };
      const lt2 = (n, ord) => {
        const s = String(n).split("."), f3 = s[1] || "", t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
        if (ord)
          return "other";
        return n10 == 1 && (n100 < 11 || n100 > 19) ? "one" : n10 >= 2 && n10 <= 9 && (n100 < 11 || n100 > 19) ? "few" : f3 != 0 ? "many" : "other";
      };
      const lv2 = (n, ord) => {
        const s = String(n).split("."), f3 = s[1] || "", v = f3.length, t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), f100 = f3.slice(-2), f10 = f3.slice(-1);
        if (ord)
          return "other";
        return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v == 2 && f100 >= 11 && f100 <= 19 ? "zero" : n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1 ? "one" : "other";
      };
      const mas2 = a2;
      const mg2 = b2;
      const mgo2 = a2;
      const mk2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f3.slice(-1), f100 = f3.slice(-2);
        if (ord)
          return i10 == 1 && i100 != 11 ? "one" : i10 == 2 && i100 != 12 ? "two" : (i10 == 7 || i10 == 8) && i100 != 17 && i100 != 18 ? "many" : "other";
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : "other";
      };
      const ml2 = a2;
      const mn2 = a2;
      const mo2 = (n, ord) => {
        const s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
        if (ord)
          return n == 1 ? "one" : "other";
        return n == 1 && v0 ? "one" : !v0 || n == 0 || n != 1 && n100 >= 1 && n100 <= 19 ? "few" : "other";
      };
      const mr2 = (n, ord) => {
        if (ord)
          return n == 1 ? "one" : n == 2 || n == 3 ? "two" : n == 4 ? "few" : "other";
        return n == 1 ? "one" : "other";
      };
      const ms2 = (n, ord) => {
        if (ord)
          return n == 1 ? "one" : "other";
        return "other";
      };
      const mt2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
        if (ord)
          return "other";
        return n == 1 ? "one" : n == 2 ? "two" : n == 0 || n100 >= 3 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 19 ? "many" : "other";
      };
      const my2 = e2;
      const nah2 = a2;
      const naq2 = f2;
      const nb2 = a2;
      const nd2 = a2;
      const ne2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n;
        if (ord)
          return t0 && n >= 1 && n <= 4 ? "one" : "other";
        return n == 1 ? "one" : "other";
      };
      const nl2 = d2;
      const nn2 = a2;
      const nnh2 = a2;
      const no2 = a2;
      const nqo2 = e2;
      const nr2 = a2;
      const nso2 = b2;
      const ny2 = a2;
      const nyn2 = a2;
      const om2 = a2;
      const or2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n;
        if (ord)
          return n == 1 || n == 5 || t0 && n >= 7 && n <= 9 ? "one" : n == 2 || n == 3 ? "two" : n == 4 ? "few" : n == 6 ? "many" : "other";
        return n == 1 ? "one" : "other";
      };
      const os2 = a2;
      const osa2 = e2;
      const pa2 = b2;
      const pap2 = a2;
      const pcm2 = c2;
      const pl2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2);
        if (ord)
          return "other";
        return n == 1 && v0 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? "few" : v0 && i != 1 && (i10 == 0 || i10 == 1) || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 12 && i100 <= 14 ? "many" : "other";
      };
      const prg2 = (n, ord) => {
        const s = String(n).split("."), f3 = s[1] || "", v = f3.length, t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), f100 = f3.slice(-2), f10 = f3.slice(-1);
        if (ord)
          return "other";
        return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v == 2 && f100 >= 11 && f100 <= 19 ? "zero" : n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1 ? "one" : "other";
      };
      const ps2 = a2;
      const pt2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        if (ord)
          return "other";
        return i == 0 || i == 1 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const pt_PT2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        if (ord)
          return "other";
        return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const rm2 = a2;
      const ro2 = (n, ord) => {
        const s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
        if (ord)
          return n == 1 ? "one" : "other";
        return n == 1 && v0 ? "one" : !v0 || n == 0 || n != 1 && n100 >= 1 && n100 <= 19 ? "few" : "other";
      };
      const rof2 = a2;
      const ru2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2);
        if (ord)
          return "other";
        return v0 && i10 == 1 && i100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? "few" : v0 && i10 == 0 || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 11 && i100 <= 14 ? "many" : "other";
      };
      const rwk2 = a2;
      const sah2 = e2;
      const saq2 = a2;
      const sat2 = f2;
      const sc2 = (n, ord) => {
        const s = String(n).split("."), v0 = !s[1];
        if (ord)
          return n == 11 || n == 8 || n == 80 || n == 800 ? "many" : "other";
        return n == 1 && v0 ? "one" : "other";
      };
      const scn2 = (n, ord) => {
        const s = String(n).split("."), v0 = !s[1];
        if (ord)
          return n == 11 || n == 8 || n == 80 || n == 800 ? "many" : "other";
        return n == 1 && v0 ? "one" : "other";
      };
      const sd2 = a2;
      const sdh2 = a2;
      const se2 = f2;
      const seh2 = a2;
      const ses2 = e2;
      const sg2 = e2;
      const sh2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f3.slice(-1), f100 = f3.slice(-2);
        if (ord)
          return "other";
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
      };
      const shi2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n;
        if (ord)
          return "other";
        return n >= 0 && n <= 1 ? "one" : t0 && n >= 2 && n <= 10 ? "few" : "other";
      };
      const si2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "";
        if (ord)
          return "other";
        return n == 0 || n == 1 || i == 0 && f3 == 1 ? "one" : "other";
      };
      const sk2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1];
        if (ord)
          return "other";
        return n == 1 && v0 ? "one" : i >= 2 && i <= 4 && v0 ? "few" : !v0 ? "many" : "other";
      };
      const sl2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i100 = i.slice(-2);
        if (ord)
          return "other";
        return v0 && i100 == 1 ? "one" : v0 && i100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || !v0 ? "few" : "other";
      };
      const sma2 = f2;
      const smi2 = f2;
      const smj2 = f2;
      const smn2 = f2;
      const sms2 = f2;
      const sn2 = a2;
      const so2 = a2;
      const sq2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
        if (ord)
          return n == 1 ? "one" : n10 == 4 && n100 != 14 ? "many" : "other";
        return n == 1 ? "one" : "other";
      };
      const sr2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f3.slice(-1), f100 = f3.slice(-2);
        if (ord)
          return "other";
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
      };
      const ss2 = a2;
      const ssy2 = a2;
      const st2 = a2;
      const su2 = e2;
      const sv2 = (n, ord) => {
        const s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
        if (ord)
          return (n10 == 1 || n10 == 2) && n100 != 11 && n100 != 12 ? "one" : "other";
        return n == 1 && v0 ? "one" : "other";
      };
      const sw2 = d2;
      const syr2 = a2;
      const ta2 = a2;
      const te2 = a2;
      const teo2 = a2;
      const th2 = e2;
      const ti2 = b2;
      const tig2 = a2;
      const tk2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1);
        if (ord)
          return n10 == 6 || n10 == 9 || n == 10 ? "few" : "other";
        return n == 1 ? "one" : "other";
      };
      const tl2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], f3 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), f10 = f3.slice(-1);
        if (ord)
          return n == 1 ? "one" : "other";
        return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? "one" : "other";
      };
      const tn2 = a2;
      const to2 = e2;
      const tpi2 = e2;
      const tr2 = a2;
      const ts2 = a2;
      const tzm2 = (n, ord) => {
        const s = String(n).split("."), t0 = Number(s[0]) == n;
        if (ord)
          return "other";
        return n == 0 || n == 1 || t0 && n >= 11 && n <= 99 ? "one" : "other";
      };
      const ug2 = a2;
      const uk2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), i10 = i.slice(-1), i100 = i.slice(-2);
        if (ord)
          return n10 == 3 && n100 != 13 ? "few" : "other";
        return v0 && i10 == 1 && i100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? "few" : v0 && i10 == 0 || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 11 && i100 <= 14 ? "many" : "other";
      };
      const und2 = e2;
      const ur2 = d2;
      const uz2 = a2;
      const ve2 = a2;
      const vec2 = (n, ord) => {
        const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
        if (ord)
          return n == 11 || n == 8 || n == 80 || n == 800 ? "many" : "other";
        return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
      };
      const vi2 = (n, ord) => {
        if (ord)
          return n == 1 ? "one" : "other";
        return "other";
      };
      const vo2 = a2;
      const vun2 = a2;
      const wa2 = b2;
      const wae2 = a2;
      const wo2 = e2;
      const xh2 = a2;
      const xog2 = a2;
      const yi2 = d2;
      const yo2 = e2;
      const yue2 = e2;
      const zh2 = e2;
      const zu2 = c2;
      var Plurals = Object.freeze({
        __proto__: null,
        af: af2,
        ak: ak2,
        am: am2,
        an: an2,
        ar: ar2,
        ars: ars2,
        as: as2,
        asa: asa2,
        ast: ast2,
        az: az2,
        bal: bal2,
        be: be2,
        bem: bem2,
        bez: bez2,
        bg: bg2,
        bho: bho2,
        bm: bm2,
        bn: bn2,
        bo: bo2,
        br: br2,
        brx: brx2,
        bs: bs2,
        ca: ca2,
        ce: ce2,
        ceb: ceb2,
        cgg: cgg2,
        chr: chr2,
        ckb: ckb2,
        cs: cs2,
        cy: cy2,
        da: da2,
        de: de2,
        doi: doi2,
        dsb: dsb2,
        dv: dv2,
        dz: dz2,
        ee: ee2,
        el: el2,
        en: en2,
        eo: eo2,
        es: es2,
        et: et2,
        eu: eu2,
        fa: fa2,
        ff: ff2,
        fi: fi2,
        fil: fil2,
        fo: fo2,
        fr: fr2,
        fur: fur2,
        fy: fy2,
        ga: ga2,
        gd: gd2,
        gl: gl2,
        gsw: gsw2,
        gu: gu2,
        guw: guw2,
        gv: gv2,
        ha: ha2,
        haw: haw2,
        he: he2,
        hi: hi2,
        hnj: hnj2,
        hr: hr2,
        hsb: hsb2,
        hu: hu2,
        hy: hy2,
        ia: ia2,
        id: id2,
        ig: ig2,
        ii: ii2,
        io: io2,
        is: is2,
        it: it2,
        iu: iu2,
        ja: ja2,
        jbo: jbo2,
        jgo: jgo2,
        jmc: jmc2,
        jv: jv2,
        jw: jw2,
        ka: ka2,
        kab: kab2,
        kaj: kaj2,
        kcg: kcg2,
        kde: kde2,
        kea: kea2,
        kk: kk2,
        kkj: kkj2,
        kl: kl2,
        km: km2,
        kn: kn2,
        ko: ko2,
        ks: ks2,
        ksb: ksb2,
        ksh: ksh2,
        ku: ku2,
        kw: kw2,
        ky: ky2,
        lag: lag2,
        lb: lb2,
        lg: lg2,
        lij: lij2,
        lkt: lkt2,
        ln: ln2,
        lo: lo2,
        lt: lt2,
        lv: lv2,
        mas: mas2,
        mg: mg2,
        mgo: mgo2,
        mk: mk2,
        ml: ml2,
        mn: mn2,
        mo: mo2,
        mr: mr2,
        ms: ms2,
        mt: mt2,
        my: my2,
        nah: nah2,
        naq: naq2,
        nb: nb2,
        nd: nd2,
        ne: ne2,
        nl: nl2,
        nn: nn2,
        nnh: nnh2,
        no: no2,
        nqo: nqo2,
        nr: nr2,
        nso: nso2,
        ny: ny2,
        nyn: nyn2,
        om: om2,
        or: or2,
        os: os2,
        osa: osa2,
        pa: pa2,
        pap: pap2,
        pcm: pcm2,
        pl: pl2,
        prg: prg2,
        ps: ps2,
        pt: pt2,
        pt_PT: pt_PT2,
        rm: rm2,
        ro: ro2,
        rof: rof2,
        ru: ru2,
        rwk: rwk2,
        sah: sah2,
        saq: saq2,
        sat: sat2,
        sc: sc2,
        scn: scn2,
        sd: sd2,
        sdh: sdh2,
        se: se2,
        seh: seh2,
        ses: ses2,
        sg: sg2,
        sh: sh2,
        shi: shi2,
        si: si2,
        sk: sk2,
        sl: sl2,
        sma: sma2,
        smi: smi2,
        smj: smj2,
        smn: smn2,
        sms: sms2,
        sn: sn2,
        so: so2,
        sq: sq2,
        sr: sr2,
        ss: ss2,
        ssy: ssy2,
        st: st2,
        su: su2,
        sv: sv2,
        sw: sw2,
        syr: syr2,
        ta: ta2,
        te: te2,
        teo: teo2,
        th: th2,
        ti: ti2,
        tig: tig2,
        tk: tk2,
        tl: tl2,
        tn: tn2,
        to: to2,
        tpi: tpi2,
        tr: tr2,
        ts: ts2,
        tzm: tzm2,
        ug: ug2,
        uk: uk2,
        und: und2,
        ur: ur2,
        uz: uz2,
        ve: ve2,
        vec: vec2,
        vi: vi2,
        vo: vo2,
        vun: vun2,
        wa: wa2,
        wae: wae2,
        wo: wo2,
        xh: xh2,
        xog: xog2,
        yi: yi2,
        yo: yo2,
        yue: yue2,
        zh: zh2,
        zu: zu2
      });
      function normalize(locale) {
        if (typeof locale !== "string" || locale.length < 2)
          throw new RangeError("Invalid language tag: ".concat(locale));
        if (locale.startsWith("pt-PT"))
          return "pt-PT";
        var m2 = locale.match(/.+?(?=[-_])/);
        return m2 ? m2[0] : locale;
      }
      function getPlural(locale) {
        if (typeof locale === "function") {
          var lc_1 = normalize(locale.name);
          return {
            isDefault: false,
            id: identifier(lc_1),
            lc: lc_1,
            locale: locale.name,
            getPlural: locale,
            cardinals: locale.cardinals || [],
            ordinals: locale.ordinals || []
          };
        }
        var lc = normalize(locale);
        var id3 = identifier(lc);
        if (isPluralId(id3)) {
          return {
            isDefault: true,
            id: id3,
            lc,
            locale,
            getCardinal: Cardinals[id3],
            getPlural: Plurals[id3],
            cardinals: PluralCategories[id3].cardinal,
            ordinals: PluralCategories[id3].ordinal
          };
        }
        return null;
      }
      function getAllPlurals(firstLocale) {
        var keys = Object.keys(Plurals).filter(function(key) {
          return key !== firstLocale;
        });
        keys.unshift(firstLocale);
        return keys.map(getPlural);
      }
      function hasPlural(locale) {
        var lc = normalize(locale);
        return identifier(lc) in Plurals;
      }
      function isPluralId(id3) {
        return id3 in Plurals;
      }
      var MessageFormat = function() {
        function MessageFormat2(locale, options) {
          this.plurals = [];
          this.options = Object.assign({
            biDiSupport: false,
            currency: "USD",
            customFormatters: {},
            localeCodeFromKey: null,
            requireAllArguments: false,
            returnType: "string",
            strict: options && options.strictNumberSign || false,
            strictPluralKeys: true
          }, options);
          if (locale === "*") {
            this.plurals = getAllPlurals(MessageFormat2.defaultLocale);
          } else if (Array.isArray(locale)) {
            this.plurals = locale.map(getPlural).filter(Boolean);
          } else if (locale) {
            var pl3 = getPlural(locale);
            if (pl3)
              this.plurals = [pl3];
          }
          if (this.plurals.length === 0) {
            var pl3 = getPlural(MessageFormat2.defaultLocale);
            this.plurals = [pl3];
          }
        }
        MessageFormat2.escape = function(str, octothorpe) {
          var esc = octothorpe ? /[#{}]/g : /[{}]/g;
          return String(str).replace(esc, "'$&'");
        };
        MessageFormat2.supportedLocalesOf = function(locales) {
          var la = Array.isArray(locales) ? locales : [locales];
          return la.filter(hasPlural);
        };
        MessageFormat2.prototype.resolvedOptions = function() {
          return __assign(__assign({}, this.options), { locale: this.plurals[0].locale, plurals: this.plurals });
        };
        MessageFormat2.prototype.compile = function(message) {
          var e_1, _a;
          var compiler = new Compiler(this.options);
          var fnBody = "return " + compiler.compile(message, this.plurals[0]);
          var nfArgs = [];
          var fnArgs = [];
          try {
            for (var _b = __values(Object.entries(compiler.runtime)), _c = _b.next(); !_c.done; _c = _b.next()) {
              var _d = __read(_c.value, 2), key = _d[0], fmt = _d[1];
              nfArgs.push(key);
              fnArgs.push(fmt);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          var fn = new (Function.bind.apply(Function, __spreadArray(__spreadArray([void 0], __read(nfArgs), false), [fnBody], false)))();
          return fn.apply(void 0, __spreadArray([], __read(fnArgs), false));
        };
        MessageFormat2.defaultLocale = "en";
        return MessageFormat2;
      }();
      return MessageFormat;
    });
  }
});

// node_modules/make-plural/plurals.mjs
var plurals_exports = {};
__export(plurals_exports, {
  af: () => af,
  ak: () => ak,
  am: () => am,
  an: () => an,
  ar: () => ar,
  ars: () => ars,
  as: () => as,
  asa: () => asa,
  ast: () => ast,
  az: () => az,
  bal: () => bal,
  be: () => be,
  bem: () => bem,
  bez: () => bez,
  bg: () => bg,
  bho: () => bho,
  bm: () => bm,
  bn: () => bn,
  bo: () => bo,
  br: () => br,
  brx: () => brx,
  bs: () => bs,
  ca: () => ca,
  ce: () => ce,
  ceb: () => ceb,
  cgg: () => cgg,
  chr: () => chr,
  ckb: () => ckb,
  cs: () => cs,
  cy: () => cy,
  da: () => da,
  de: () => de,
  doi: () => doi,
  dsb: () => dsb,
  dv: () => dv,
  dz: () => dz,
  ee: () => ee,
  el: () => el,
  en: () => en,
  eo: () => eo,
  es: () => es,
  et: () => et,
  eu: () => eu,
  fa: () => fa,
  ff: () => ff,
  fi: () => fi,
  fil: () => fil,
  fo: () => fo,
  fr: () => fr,
  fur: () => fur,
  fy: () => fy,
  ga: () => ga,
  gd: () => gd,
  gl: () => gl,
  gsw: () => gsw,
  gu: () => gu,
  guw: () => guw,
  gv: () => gv,
  ha: () => ha,
  haw: () => haw,
  he: () => he,
  hi: () => hi,
  hnj: () => hnj,
  hr: () => hr,
  hsb: () => hsb,
  hu: () => hu,
  hy: () => hy,
  ia: () => ia,
  id: () => id,
  ig: () => ig,
  ii: () => ii,
  io: () => io,
  is: () => is,
  it: () => it,
  iu: () => iu,
  ja: () => ja,
  jbo: () => jbo,
  jgo: () => jgo,
  jmc: () => jmc,
  jv: () => jv,
  jw: () => jw,
  ka: () => ka,
  kab: () => kab,
  kaj: () => kaj,
  kcg: () => kcg,
  kde: () => kde,
  kea: () => kea,
  kk: () => kk,
  kkj: () => kkj,
  kl: () => kl,
  km: () => km,
  kn: () => kn,
  ko: () => ko,
  ks: () => ks,
  ksb: () => ksb,
  ksh: () => ksh,
  ku: () => ku,
  kw: () => kw,
  ky: () => ky,
  lag: () => lag,
  lb: () => lb,
  lg: () => lg,
  lij: () => lij,
  lkt: () => lkt,
  ln: () => ln,
  lo: () => lo,
  lt: () => lt,
  lv: () => lv,
  mas: () => mas,
  mg: () => mg,
  mgo: () => mgo,
  mk: () => mk,
  ml: () => ml,
  mn: () => mn,
  mo: () => mo,
  mr: () => mr,
  ms: () => ms,
  mt: () => mt,
  my: () => my,
  nah: () => nah,
  naq: () => naq,
  nb: () => nb,
  nd: () => nd,
  ne: () => ne,
  nl: () => nl,
  nn: () => nn,
  nnh: () => nnh,
  no: () => no,
  nqo: () => nqo,
  nr: () => nr,
  nso: () => nso,
  ny: () => ny,
  nyn: () => nyn,
  om: () => om,
  or: () => or,
  os: () => os,
  osa: () => osa,
  pa: () => pa,
  pap: () => pap,
  pcm: () => pcm,
  pl: () => pl,
  prg: () => prg,
  ps: () => ps,
  pt: () => pt,
  pt_PT: () => pt_PT,
  rm: () => rm,
  ro: () => ro,
  rof: () => rof,
  ru: () => ru,
  rwk: () => rwk,
  sah: () => sah,
  saq: () => saq,
  sat: () => sat,
  sc: () => sc,
  scn: () => scn,
  sd: () => sd,
  sdh: () => sdh,
  se: () => se,
  seh: () => seh,
  ses: () => ses,
  sg: () => sg,
  sh: () => sh,
  shi: () => shi,
  si: () => si,
  sk: () => sk,
  sl: () => sl,
  sma: () => sma,
  smi: () => smi,
  smj: () => smj,
  smn: () => smn,
  sms: () => sms,
  sn: () => sn,
  so: () => so,
  sq: () => sq,
  sr: () => sr,
  ss: () => ss,
  ssy: () => ssy,
  st: () => st,
  su: () => su,
  sv: () => sv,
  sw: () => sw,
  syr: () => syr,
  ta: () => ta,
  te: () => te,
  teo: () => teo,
  th: () => th,
  ti: () => ti,
  tig: () => tig,
  tk: () => tk,
  tl: () => tl,
  tn: () => tn,
  to: () => to,
  tpi: () => tpi,
  tr: () => tr,
  ts: () => ts,
  tzm: () => tzm,
  ug: () => ug,
  uk: () => uk,
  und: () => und,
  ur: () => ur,
  uz: () => uz,
  ve: () => ve,
  vec: () => vec,
  vi: () => vi,
  vo: () => vo,
  vun: () => vun,
  wa: () => wa,
  wae: () => wae,
  wo: () => wo,
  xh: () => xh,
  xog: () => xog,
  yi: () => yi,
  yo: () => yo,
  yue: () => yue,
  zh: () => zh,
  zu: () => zu
});
var a, b, c, d, e, f, af, ak, am, an, ar, ars, as, asa, ast, az, bal, be, bem, bez, bg, bho, bm, bn, bo, br, brx, bs, ca, ce, ceb, cgg, chr, ckb, cs, cy, da, de, doi, dsb, dv, dz, ee, el, en, eo, es, et, eu, fa, ff, fi, fil, fo, fr, fur, fy, ga, gd, gl, gsw, gu, guw, gv, ha, haw, he, hi, hnj, hr, hsb, hu, hy, ia, id, ig, ii, io, is, it, iu, ja, jbo, jgo, jmc, jv, jw, ka, kab, kaj, kcg, kde, kea, kk, kkj, kl, km, kn, ko, ks, ksb, ksh, ku, kw, ky, lag, lb, lg, lij, lkt, ln, lo, lt, lv, mas, mg, mgo, mk, ml, mn, mo, mr, ms, mt, my, nah, naq, nb, nd, ne, nl, nn, nnh, no, nqo, nr, nso, ny, nyn, om, or, os, osa, pa, pap, pcm, pl, prg, ps, pt, pt_PT, rm, ro, rof, ru, rwk, sah, saq, sat, sc, scn, sd, sdh, se, seh, ses, sg, sh, shi, si, sk, sl, sma, smi, smj, smn, sms, sn, so, sq, sr, ss, ssy, st, su, sv, sw, syr, ta, te, teo, th, ti, tig, tk, tl, tn, to, tpi, tr, ts, tzm, ug, uk, und, ur, uz, ve, vec, vi, vo, vun, wa, wae, wo, xh, xog, yi, yo, yue, zh, zu;
var init_plurals = __esm({
  "node_modules/make-plural/plurals.mjs"() {
    a = (n, ord) => {
      if (ord)
        return "other";
      return n == 1 ? "one" : "other";
    };
    b = (n, ord) => {
      if (ord)
        return "other";
      return n == 0 || n == 1 ? "one" : "other";
    };
    c = (n, ord) => {
      if (ord)
        return "other";
      return n >= 0 && n <= 1 ? "one" : "other";
    };
    d = (n, ord) => {
      const s = String(n).split("."), v0 = !s[1];
      if (ord)
        return "other";
      return n == 1 && v0 ? "one" : "other";
    };
    e = (n, ord) => "other";
    f = (n, ord) => {
      if (ord)
        return "other";
      return n == 1 ? "one" : n == 2 ? "two" : "other";
    };
    af = a;
    ak = b;
    am = c;
    an = a;
    ar = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
      if (ord)
        return "other";
      return n == 0 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n100 >= 3 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 99 ? "many" : "other";
    };
    ars = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
      if (ord)
        return "other";
      return n == 0 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n100 >= 3 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 99 ? "many" : "other";
    };
    as = (n, ord) => {
      if (ord)
        return n == 1 || n == 5 || n == 7 || n == 8 || n == 9 || n == 10 ? "one" : n == 2 || n == 3 ? "two" : n == 4 ? "few" : n == 6 ? "many" : "other";
      return n >= 0 && n <= 1 ? "one" : "other";
    };
    asa = a;
    ast = d;
    az = (n, ord) => {
      const s = String(n).split("."), i = s[0], i10 = i.slice(-1), i100 = i.slice(-2), i1000 = i.slice(-3);
      if (ord)
        return i10 == 1 || i10 == 2 || i10 == 5 || i10 == 7 || i10 == 8 || (i100 == 20 || i100 == 50 || i100 == 70 || i100 == 80) ? "one" : i10 == 3 || i10 == 4 || (i1000 == 100 || i1000 == 200 || i1000 == 300 || i1000 == 400 || i1000 == 500 || i1000 == 600 || i1000 == 700 || i1000 == 800 || i1000 == 900) ? "few" : i == 0 || i10 == 6 || (i100 == 40 || i100 == 60 || i100 == 90) ? "many" : "other";
      return n == 1 ? "one" : "other";
    };
    bal = (n, ord) => n == 1 ? "one" : "other";
    be = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
      if (ord)
        return (n10 == 2 || n10 == 3) && n100 != 12 && n100 != 13 ? "few" : "other";
      return n10 == 1 && n100 != 11 ? "one" : n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) ? "few" : t0 && n10 == 0 || n10 >= 5 && n10 <= 9 || n100 >= 11 && n100 <= 14 ? "many" : "other";
    };
    bem = a;
    bez = a;
    bg = a;
    bho = b;
    bm = e;
    bn = (n, ord) => {
      if (ord)
        return n == 1 || n == 5 || n == 7 || n == 8 || n == 9 || n == 10 ? "one" : n == 2 || n == 3 ? "two" : n == 4 ? "few" : n == 6 ? "many" : "other";
      return n >= 0 && n <= 1 ? "one" : "other";
    };
    bo = e;
    br = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), n1000000 = t0 && s[0].slice(-6);
      if (ord)
        return "other";
      return n10 == 1 && n100 != 11 && n100 != 71 && n100 != 91 ? "one" : n10 == 2 && n100 != 12 && n100 != 72 && n100 != 92 ? "two" : (n10 == 3 || n10 == 4 || n10 == 9) && (n100 < 10 || n100 > 19) && (n100 < 70 || n100 > 79) && (n100 < 90 || n100 > 99) ? "few" : n != 0 && t0 && n1000000 == 0 ? "many" : "other";
    };
    brx = a;
    bs = (n, ord) => {
      const s = String(n).split("."), i = s[0], f2 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f2.slice(-1), f100 = f2.slice(-2);
      if (ord)
        return "other";
      return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
    };
    ca = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
      if (ord)
        return n == 1 || n == 3 ? "one" : n == 2 ? "two" : n == 4 ? "few" : "other";
      return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
    };
    ce = a;
    ceb = (n, ord) => {
      const s = String(n).split("."), i = s[0], f2 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), f10 = f2.slice(-1);
      if (ord)
        return "other";
      return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? "one" : "other";
    };
    cgg = a;
    chr = a;
    ckb = a;
    cs = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1];
      if (ord)
        return "other";
      return n == 1 && v0 ? "one" : i >= 2 && i <= 4 && v0 ? "few" : !v0 ? "many" : "other";
    };
    cy = (n, ord) => {
      if (ord)
        return n == 0 || n == 7 || n == 8 || n == 9 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n == 3 || n == 4 ? "few" : n == 5 || n == 6 ? "many" : "other";
      return n == 0 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n == 3 ? "few" : n == 6 ? "many" : "other";
    };
    da = (n, ord) => {
      const s = String(n).split("."), i = s[0], t0 = Number(s[0]) == n;
      if (ord)
        return "other";
      return n == 1 || !t0 && (i == 0 || i == 1) ? "one" : "other";
    };
    de = d;
    doi = c;
    dsb = (n, ord) => {
      const s = String(n).split("."), i = s[0], f2 = s[1] || "", v0 = !s[1], i100 = i.slice(-2), f100 = f2.slice(-2);
      if (ord)
        return "other";
      return v0 && i100 == 1 || f100 == 1 ? "one" : v0 && i100 == 2 || f100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || (f100 == 3 || f100 == 4) ? "few" : "other";
    };
    dv = a;
    dz = e;
    ee = a;
    el = a;
    en = (n, ord) => {
      const s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
      if (ord)
        return n10 == 1 && n100 != 11 ? "one" : n10 == 2 && n100 != 12 ? "two" : n10 == 3 && n100 != 13 ? "few" : "other";
      return n == 1 && v0 ? "one" : "other";
    };
    eo = a;
    es = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
      if (ord)
        return "other";
      return n == 1 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
    };
    et = d;
    eu = a;
    fa = c;
    ff = (n, ord) => {
      if (ord)
        return "other";
      return n >= 0 && n < 2 ? "one" : "other";
    };
    fi = d;
    fil = (n, ord) => {
      const s = String(n).split("."), i = s[0], f2 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), f10 = f2.slice(-1);
      if (ord)
        return n == 1 ? "one" : "other";
      return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? "one" : "other";
    };
    fo = a;
    fr = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
      if (ord)
        return n == 1 ? "one" : "other";
      return n >= 0 && n < 2 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
    };
    fur = a;
    fy = d;
    ga = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n;
      if (ord)
        return n == 1 ? "one" : "other";
      return n == 1 ? "one" : n == 2 ? "two" : t0 && n >= 3 && n <= 6 ? "few" : t0 && n >= 7 && n <= 10 ? "many" : "other";
    };
    gd = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n;
      if (ord)
        return n == 1 || n == 11 ? "one" : n == 2 || n == 12 ? "two" : n == 3 || n == 13 ? "few" : "other";
      return n == 1 || n == 11 ? "one" : n == 2 || n == 12 ? "two" : t0 && n >= 3 && n <= 10 || t0 && n >= 13 && n <= 19 ? "few" : "other";
    };
    gl = d;
    gsw = a;
    gu = (n, ord) => {
      if (ord)
        return n == 1 ? "one" : n == 2 || n == 3 ? "two" : n == 4 ? "few" : n == 6 ? "many" : "other";
      return n >= 0 && n <= 1 ? "one" : "other";
    };
    guw = b;
    gv = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2);
      if (ord)
        return "other";
      return v0 && i10 == 1 ? "one" : v0 && i10 == 2 ? "two" : v0 && (i100 == 0 || i100 == 20 || i100 == 40 || i100 == 60 || i100 == 80) ? "few" : !v0 ? "many" : "other";
    };
    ha = a;
    haw = a;
    he = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1];
      if (ord)
        return "other";
      return i == 1 && v0 || i == 0 && !v0 ? "one" : i == 2 && v0 ? "two" : "other";
    };
    hi = (n, ord) => {
      if (ord)
        return n == 1 ? "one" : n == 2 || n == 3 ? "two" : n == 4 ? "few" : n == 6 ? "many" : "other";
      return n >= 0 && n <= 1 ? "one" : "other";
    };
    hnj = e;
    hr = (n, ord) => {
      const s = String(n).split("."), i = s[0], f2 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f2.slice(-1), f100 = f2.slice(-2);
      if (ord)
        return "other";
      return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
    };
    hsb = (n, ord) => {
      const s = String(n).split("."), i = s[0], f2 = s[1] || "", v0 = !s[1], i100 = i.slice(-2), f100 = f2.slice(-2);
      if (ord)
        return "other";
      return v0 && i100 == 1 || f100 == 1 ? "one" : v0 && i100 == 2 || f100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || (f100 == 3 || f100 == 4) ? "few" : "other";
    };
    hu = (n, ord) => {
      if (ord)
        return n == 1 || n == 5 ? "one" : "other";
      return n == 1 ? "one" : "other";
    };
    hy = (n, ord) => {
      if (ord)
        return n == 1 ? "one" : "other";
      return n >= 0 && n < 2 ? "one" : "other";
    };
    ia = d;
    id = e;
    ig = e;
    ii = e;
    io = d;
    is = (n, ord) => {
      const s = String(n).split("."), i = s[0], t = (s[1] || "").replace(/0+$/, ""), t0 = Number(s[0]) == n, i10 = i.slice(-1), i100 = i.slice(-2);
      if (ord)
        return "other";
      return t0 && i10 == 1 && i100 != 11 || t % 10 == 1 && t % 100 != 11 ? "one" : "other";
    };
    it = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
      if (ord)
        return n == 11 || n == 8 || n == 80 || n == 800 ? "many" : "other";
      return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
    };
    iu = f;
    ja = e;
    jbo = e;
    jgo = a;
    jmc = a;
    jv = e;
    jw = e;
    ka = (n, ord) => {
      const s = String(n).split("."), i = s[0], i100 = i.slice(-2);
      if (ord)
        return i == 1 ? "one" : i == 0 || (i100 >= 2 && i100 <= 20 || i100 == 40 || i100 == 60 || i100 == 80) ? "many" : "other";
      return n == 1 ? "one" : "other";
    };
    kab = (n, ord) => {
      if (ord)
        return "other";
      return n >= 0 && n < 2 ? "one" : "other";
    };
    kaj = a;
    kcg = a;
    kde = e;
    kea = e;
    kk = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1);
      if (ord)
        return n10 == 6 || n10 == 9 || t0 && n10 == 0 && n != 0 ? "many" : "other";
      return n == 1 ? "one" : "other";
    };
    kkj = a;
    kl = a;
    km = e;
    kn = c;
    ko = e;
    ks = a;
    ksb = a;
    ksh = (n, ord) => {
      if (ord)
        return "other";
      return n == 0 ? "zero" : n == 1 ? "one" : "other";
    };
    ku = a;
    kw = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2), n1000 = t0 && s[0].slice(-3), n100000 = t0 && s[0].slice(-5), n1000000 = t0 && s[0].slice(-6);
      if (ord)
        return t0 && n >= 1 && n <= 4 || (n100 >= 1 && n100 <= 4 || n100 >= 21 && n100 <= 24 || n100 >= 41 && n100 <= 44 || n100 >= 61 && n100 <= 64 || n100 >= 81 && n100 <= 84) ? "one" : n == 5 || n100 == 5 ? "many" : "other";
      return n == 0 ? "zero" : n == 1 ? "one" : n100 == 2 || n100 == 22 || n100 == 42 || n100 == 62 || n100 == 82 || t0 && n1000 == 0 && (n100000 >= 1e3 && n100000 <= 2e4 || n100000 == 4e4 || n100000 == 6e4 || n100000 == 8e4) || n != 0 && n1000000 == 1e5 ? "two" : n100 == 3 || n100 == 23 || n100 == 43 || n100 == 63 || n100 == 83 ? "few" : n != 1 && (n100 == 1 || n100 == 21 || n100 == 41 || n100 == 61 || n100 == 81) ? "many" : "other";
    };
    ky = a;
    lag = (n, ord) => {
      const s = String(n).split("."), i = s[0];
      if (ord)
        return "other";
      return n == 0 ? "zero" : (i == 0 || i == 1) && n != 0 ? "one" : "other";
    };
    lb = a;
    lg = a;
    lij = (n, ord) => {
      const s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n;
      if (ord)
        return n == 11 || n == 8 || t0 && n >= 80 && n <= 89 || t0 && n >= 800 && n <= 899 ? "many" : "other";
      return n == 1 && v0 ? "one" : "other";
    };
    lkt = e;
    ln = b;
    lo = (n, ord) => {
      if (ord)
        return n == 1 ? "one" : "other";
      return "other";
    };
    lt = (n, ord) => {
      const s = String(n).split("."), f2 = s[1] || "", t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
      if (ord)
        return "other";
      return n10 == 1 && (n100 < 11 || n100 > 19) ? "one" : n10 >= 2 && n10 <= 9 && (n100 < 11 || n100 > 19) ? "few" : f2 != 0 ? "many" : "other";
    };
    lv = (n, ord) => {
      const s = String(n).split("."), f2 = s[1] || "", v = f2.length, t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), f100 = f2.slice(-2), f10 = f2.slice(-1);
      if (ord)
        return "other";
      return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v == 2 && (f100 >= 11 && f100 <= 19) ? "zero" : n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1 ? "one" : "other";
    };
    mas = a;
    mg = b;
    mgo = a;
    mk = (n, ord) => {
      const s = String(n).split("."), i = s[0], f2 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f2.slice(-1), f100 = f2.slice(-2);
      if (ord)
        return i10 == 1 && i100 != 11 ? "one" : i10 == 2 && i100 != 12 ? "two" : (i10 == 7 || i10 == 8) && i100 != 17 && i100 != 18 ? "many" : "other";
      return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : "other";
    };
    ml = a;
    mn = a;
    mo = (n, ord) => {
      const s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
      if (ord)
        return n == 1 ? "one" : "other";
      return n == 1 && v0 ? "one" : !v0 || n == 0 || n != 1 && (n100 >= 1 && n100 <= 19) ? "few" : "other";
    };
    mr = (n, ord) => {
      if (ord)
        return n == 1 ? "one" : n == 2 || n == 3 ? "two" : n == 4 ? "few" : "other";
      return n == 1 ? "one" : "other";
    };
    ms = (n, ord) => {
      if (ord)
        return n == 1 ? "one" : "other";
      return "other";
    };
    mt = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
      if (ord)
        return "other";
      return n == 1 ? "one" : n == 2 ? "two" : n == 0 || n100 >= 3 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 19 ? "many" : "other";
    };
    my = e;
    nah = a;
    naq = f;
    nb = a;
    nd = a;
    ne = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n;
      if (ord)
        return t0 && n >= 1 && n <= 4 ? "one" : "other";
      return n == 1 ? "one" : "other";
    };
    nl = d;
    nn = a;
    nnh = a;
    no = a;
    nqo = e;
    nr = a;
    nso = b;
    ny = a;
    nyn = a;
    om = a;
    or = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n;
      if (ord)
        return n == 1 || n == 5 || t0 && n >= 7 && n <= 9 ? "one" : n == 2 || n == 3 ? "two" : n == 4 ? "few" : n == 6 ? "many" : "other";
      return n == 1 ? "one" : "other";
    };
    os = a;
    osa = e;
    pa = b;
    pap = a;
    pcm = c;
    pl = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2);
      if (ord)
        return "other";
      return n == 1 && v0 ? "one" : v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14) ? "few" : v0 && i != 1 && (i10 == 0 || i10 == 1) || v0 && (i10 >= 5 && i10 <= 9) || v0 && (i100 >= 12 && i100 <= 14) ? "many" : "other";
    };
    prg = (n, ord) => {
      const s = String(n).split("."), f2 = s[1] || "", v = f2.length, t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), f100 = f2.slice(-2), f10 = f2.slice(-1);
      if (ord)
        return "other";
      return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v == 2 && (f100 >= 11 && f100 <= 19) ? "zero" : n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1 ? "one" : "other";
    };
    ps = a;
    pt = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
      if (ord)
        return "other";
      return i == 0 || i == 1 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
    };
    pt_PT = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
      if (ord)
        return "other";
      return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
    };
    rm = a;
    ro = (n, ord) => {
      const s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
      if (ord)
        return n == 1 ? "one" : "other";
      return n == 1 && v0 ? "one" : !v0 || n == 0 || n != 1 && (n100 >= 1 && n100 <= 19) ? "few" : "other";
    };
    rof = a;
    ru = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2);
      if (ord)
        return "other";
      return v0 && i10 == 1 && i100 != 11 ? "one" : v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14) ? "few" : v0 && i10 == 0 || v0 && (i10 >= 5 && i10 <= 9) || v0 && (i100 >= 11 && i100 <= 14) ? "many" : "other";
    };
    rwk = a;
    sah = e;
    saq = a;
    sat = f;
    sc = (n, ord) => {
      const s = String(n).split("."), v0 = !s[1];
      if (ord)
        return n == 11 || n == 8 || n == 80 || n == 800 ? "many" : "other";
      return n == 1 && v0 ? "one" : "other";
    };
    scn = (n, ord) => {
      const s = String(n).split("."), v0 = !s[1];
      if (ord)
        return n == 11 || n == 8 || n == 80 || n == 800 ? "many" : "other";
      return n == 1 && v0 ? "one" : "other";
    };
    sd = a;
    sdh = a;
    se = f;
    seh = a;
    ses = e;
    sg = e;
    sh = (n, ord) => {
      const s = String(n).split("."), i = s[0], f2 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f2.slice(-1), f100 = f2.slice(-2);
      if (ord)
        return "other";
      return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
    };
    shi = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n;
      if (ord)
        return "other";
      return n >= 0 && n <= 1 ? "one" : t0 && n >= 2 && n <= 10 ? "few" : "other";
    };
    si = (n, ord) => {
      const s = String(n).split("."), i = s[0], f2 = s[1] || "";
      if (ord)
        return "other";
      return n == 0 || n == 1 || i == 0 && f2 == 1 ? "one" : "other";
    };
    sk = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1];
      if (ord)
        return "other";
      return n == 1 && v0 ? "one" : i >= 2 && i <= 4 && v0 ? "few" : !v0 ? "many" : "other";
    };
    sl = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1], i100 = i.slice(-2);
      if (ord)
        return "other";
      return v0 && i100 == 1 ? "one" : v0 && i100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || !v0 ? "few" : "other";
    };
    sma = f;
    smi = f;
    smj = f;
    smn = f;
    sms = f;
    sn = a;
    so = a;
    sq = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
      if (ord)
        return n == 1 ? "one" : n10 == 4 && n100 != 14 ? "many" : "other";
      return n == 1 ? "one" : "other";
    };
    sr = (n, ord) => {
      const s = String(n).split("."), i = s[0], f2 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f2.slice(-1), f100 = f2.slice(-2);
      if (ord)
        return "other";
      return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
    };
    ss = a;
    ssy = a;
    st = a;
    su = e;
    sv = (n, ord) => {
      const s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
      if (ord)
        return (n10 == 1 || n10 == 2) && n100 != 11 && n100 != 12 ? "one" : "other";
      return n == 1 && v0 ? "one" : "other";
    };
    sw = d;
    syr = a;
    ta = a;
    te = a;
    teo = a;
    th = e;
    ti = b;
    tig = a;
    tk = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1);
      if (ord)
        return n10 == 6 || n10 == 9 || n == 10 ? "few" : "other";
      return n == 1 ? "one" : "other";
    };
    tl = (n, ord) => {
      const s = String(n).split("."), i = s[0], f2 = s[1] || "", v0 = !s[1], i10 = i.slice(-1), f10 = f2.slice(-1);
      if (ord)
        return n == 1 ? "one" : "other";
      return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? "one" : "other";
    };
    tn = a;
    to = e;
    tpi = e;
    tr = a;
    ts = a;
    tzm = (n, ord) => {
      const s = String(n).split("."), t0 = Number(s[0]) == n;
      if (ord)
        return "other";
      return n == 0 || n == 1 || t0 && n >= 11 && n <= 99 ? "one" : "other";
    };
    ug = a;
    uk = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1], t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), i10 = i.slice(-1), i100 = i.slice(-2);
      if (ord)
        return n10 == 3 && n100 != 13 ? "few" : "other";
      return v0 && i10 == 1 && i100 != 11 ? "one" : v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14) ? "few" : v0 && i10 == 0 || v0 && (i10 >= 5 && i10 <= 9) || v0 && (i100 >= 11 && i100 <= 14) ? "many" : "other";
    };
    und = e;
    ur = d;
    uz = a;
    ve = a;
    vec = (n, ord) => {
      const s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
      if (ord)
        return n == 11 || n == 8 || n == 80 || n == 800 ? "many" : "other";
      return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
    };
    vi = (n, ord) => {
      if (ord)
        return n == 1 ? "one" : "other";
      return "other";
    };
    vo = a;
    vun = a;
    wa = b;
    wae = a;
    wo = e;
    xh = a;
    xog = a;
    yi = d;
    yo = e;
    yue = e;
    zh = e;
    zu = c;
  }
});

// node_modules/math-interval-parser/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/math-interval-parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var patternParts = {
      value: "[-+]?(?:Infinity|[[0-9]*\\.?\\d*(?:[eE][-+]?\\d+)?)",
      leftBrace: "[\\(\\]\\[]",
      delimeter: ",",
      rightBrace: "[\\)\\]\\[]"
    };
    var PATTERN = new RegExp("(" + patternParts.leftBrace + ")" + ("(" + patternParts.value + ")?") + ("(" + patternParts.delimeter + ")?") + ("(" + patternParts.value + ")?") + ("(" + patternParts.rightBrace + ")"));
    function execPattern(str) {
      var match = PATTERN.exec(str);
      if (!match) {
        return null;
      }
      var _ = match[0], leftBrace = match[1], fromValue = match[2], delimeter = match[3], toValue = match[4], rightBrace = match[5];
      return {
        leftBrace,
        fromValue,
        delimeter,
        toValue,
        rightBrace
      };
    }
    function parse(str) {
      var match = execPattern(str);
      if (!match) {
        return null;
      }
      return {
        from: {
          value: match.fromValue !== void 0 ? +match.fromValue : -Infinity,
          included: match.leftBrace === "["
        },
        to: {
          value: match.toValue !== void 0 ? +match.toValue : match.delimeter ? Infinity : match.fromValue !== void 0 ? +match.fromValue : NaN,
          included: match.rightBrace === "]"
        }
      };
    }
    function check(interval) {
      if (interval.from.value === interval.to.value) {
        return interval.from.included && interval.to.included;
      }
      return Math.min(interval.from.value, interval.to.value) === interval.from.value;
    }
    function entry(str) {
      var interval = parse(str);
      if (!interval || !check(interval)) {
        return null;
      }
      return interval;
    }
    exports.default = entry;
  }
});

// node_modules/i18n/i18n.js
var require_i18n = __commonJS({
  "node_modules/i18n/i18n.js"(exports, module) {
    "use strict";
    var printf = require_printf().printf;
    var pkgVersion = require_package().version;
    var fs = require_fs();
    var url = require_url();
    var path = require_path();
    var debug = require_browser()("i18n:debug");
    var warn = require_browser()("i18n:warn");
    var error = require_browser()("i18n:error");
    var Mustache = require_mustache();
    var Messageformat = require_messageformat();
    var MakePlural = (init_plurals(), __toCommonJS(plurals_exports));
    var parseInterval = require_lib2().default;
    var escapeRegExp = (string) => string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    var i18n = function I18n(_OPTS = false) {
      const MessageformatInstanceForLocale = {};
      const PluralsForLocale = {};
      let locales = {};
      const api = {
        __: "__",
        __n: "__n",
        __l: "__l",
        __h: "__h",
        __mf: "__mf",
        getLocale: "getLocale",
        setLocale: "setLocale",
        getCatalog: "getCatalog",
        getLocales: "getLocales",
        addLocale: "addLocale",
        removeLocale: "removeLocale"
      };
      const mustacheConfig = {
        tags: ["{{", "}}"],
        disable: false
      };
      let mustacheRegex;
      const pathsep = path.sep;
      let autoReload;
      let cookiename;
      let languageHeaderName;
      let defaultLocale;
      let retryInDefaultLocale;
      let directory;
      let directoryPermissions;
      let extension;
      let fallbacks;
      let indent;
      let logDebugFn;
      let logErrorFn;
      let logWarnFn;
      let preserveLegacyCase;
      let objectNotation;
      let prefix;
      let queryParameter;
      let register;
      let updateFiles;
      let syncFiles;
      let missingKeyFn;
      let parser;
      const i18n2 = {};
      i18n2.version = pkgVersion;
      i18n2.configure = function i18nConfigure(opt) {
        locales = {};
        if (opt.api && typeof opt.api === "object") {
          for (const method in opt.api) {
            if (Object.prototype.hasOwnProperty.call(opt.api, method)) {
              const alias = opt.api[method];
              if (typeof api[method] !== "undefined") {
                api[method] = alias;
              }
            }
          }
        }
        if (typeof opt.register === "object") {
          register = opt.register;
          if (Array.isArray(opt.register)) {
            register = opt.register;
            register.forEach(applyAPItoObject);
          } else {
            applyAPItoObject(opt.register);
          }
        }
        cookiename = typeof opt.cookie === "string" ? opt.cookie : null;
        languageHeaderName = typeof opt.header === "string" ? opt.header : "accept-language";
        queryParameter = typeof opt.queryParameter === "string" ? opt.queryParameter : null;
        directory = typeof opt.directory === "string" ? opt.directory : path.join(__dirname, "locales");
        directoryPermissions = typeof opt.directoryPermissions === "string" ? parseInt(opt.directoryPermissions, 8) : null;
        updateFiles = typeof opt.updateFiles === "boolean" ? opt.updateFiles : true;
        syncFiles = typeof opt.syncFiles === "boolean" ? opt.syncFiles : false;
        indent = typeof opt.indent === "string" ? opt.indent : "	";
        prefix = typeof opt.prefix === "string" ? opt.prefix : "";
        extension = typeof opt.extension === "string" ? opt.extension : ".json";
        defaultLocale = typeof opt.defaultLocale === "string" ? opt.defaultLocale : "en";
        retryInDefaultLocale = typeof opt.retryInDefaultLocale === "boolean" ? opt.retryInDefaultLocale : false;
        autoReload = typeof opt.autoReload === "boolean" ? opt.autoReload : false;
        objectNotation = typeof opt.objectNotation !== "undefined" ? opt.objectNotation : false;
        if (objectNotation === true)
          objectNotation = ".";
        fallbacks = typeof opt.fallbacks === "object" ? opt.fallbacks : {};
        logDebugFn = typeof opt.logDebugFn === "function" ? opt.logDebugFn : debug;
        logWarnFn = typeof opt.logWarnFn === "function" ? opt.logWarnFn : warn;
        logErrorFn = typeof opt.logErrorFn === "function" ? opt.logErrorFn : error;
        preserveLegacyCase = typeof opt.preserveLegacyCase === "boolean" ? opt.preserveLegacyCase : true;
        missingKeyFn = typeof opt.missingKeyFn === "function" ? opt.missingKeyFn : missingKey;
        parser = typeof opt.parser === "object" && typeof opt.parser.parse === "function" && typeof opt.parser.stringify === "function" ? opt.parser : JSON;
        opt.locales = opt.staticCatalog ? Object.keys(opt.staticCatalog) : opt.locales || guessLocales(directory);
        if (opt.staticCatalog) {
          updateFiles = false;
          autoReload = false;
          syncFiles = false;
        }
        if (opt.mustacheConfig) {
          if (Array.isArray(opt.mustacheConfig.tags)) {
            mustacheConfig.tags = opt.mustacheConfig.tags;
          }
          if (opt.mustacheConfig.disable === true) {
            mustacheConfig.disable = true;
          }
        }
        const [start, end] = mustacheConfig.tags;
        mustacheRegex = new RegExp(escapeRegExp(start) + ".*" + escapeRegExp(end));
        if (Array.isArray(opt.locales)) {
          if (opt.staticCatalog) {
            locales = opt.staticCatalog;
          } else {
            opt.locales.forEach(read);
          }
          if (autoReload) {
            fs.watch(directory, (event, filename) => {
              const localeFromFile = guessLocaleFromFile(filename);
              if (localeFromFile && opt.locales.indexOf(localeFromFile) > -1) {
                logDebug('Auto reloading locale file "' + filename + '".');
                read(localeFromFile);
              }
            });
          }
        }
      };
      i18n2.init = function i18nInit(request, response, next) {
        if (typeof request === "object") {
          guessLanguage(request);
          applyAPItoObject(request);
          i18n2.setLocale(request, request.locale);
        } else {
          return logError(
            "i18n.init must be called with one parameter minimum, ie. i18n.init(req)"
          );
        }
        if (typeof response === "object") {
          applyAPItoObject(response);
          i18n2.setLocale(response, request.locale);
        }
        if (typeof next === "function") {
          return next();
        }
      };
      i18n2.__ = function i18nTranslate(phrase) {
        let msg;
        const argv = parseArgv(arguments);
        const namedValues = argv[0];
        const args = argv[1];
        if (typeof phrase === "object") {
          if (typeof phrase.locale === "string" && typeof phrase.phrase === "string") {
            msg = translate(phrase.locale, phrase.phrase);
          }
        } else {
          msg = translate(getLocaleFromObject(this), phrase);
        }
        if (typeof msg === "object" && msg.one) {
          msg = msg.one;
        }
        if (typeof msg === "object" && msg.other) {
          msg = msg.other;
        }
        return postProcess(msg, namedValues, args);
      };
      i18n2.__mf = function i18nMessageformat(phrase) {
        let msg, mf, f2;
        let targetLocale = defaultLocale;
        const argv = parseArgv(arguments);
        const namedValues = argv[0];
        const args = argv[1];
        if (typeof phrase === "object") {
          if (typeof phrase.locale === "string" && typeof phrase.phrase === "string") {
            msg = phrase.phrase;
            targetLocale = phrase.locale;
          }
        } else {
          msg = phrase;
          targetLocale = getLocaleFromObject(this);
        }
        msg = translate(targetLocale, msg);
        if (MessageformatInstanceForLocale[targetLocale]) {
          mf = MessageformatInstanceForLocale[targetLocale];
        } else {
          mf = new Messageformat(targetLocale);
          mf.compiledFunctions = {};
          MessageformatInstanceForLocale[targetLocale] = mf;
        }
        if (mf.compiledFunctions[msg]) {
          f2 = mf.compiledFunctions[msg];
        } else {
          f2 = mf.compile(msg);
          mf.compiledFunctions[msg] = f2;
        }
        return postProcess(f2(namedValues), namedValues, args);
      };
      i18n2.__l = function i18nTranslationList(phrase) {
        const translations = [];
        Object.keys(locales).sort().forEach((l) => {
          translations.push(i18n2.__({ phrase, locale: l }));
        });
        return translations;
      };
      i18n2.__h = function i18nTranslationHash(phrase) {
        const translations = [];
        Object.keys(locales).sort().forEach((l) => {
          const hash = {};
          hash[l] = i18n2.__({ phrase, locale: l });
          translations.push(hash);
        });
        return translations;
      };
      i18n2.__n = function i18nTranslatePlural(singular, plural, count) {
        let msg;
        let namedValues;
        let targetLocale;
        let args = [];
        if (argsEndWithNamedObject(arguments)) {
          namedValues = arguments[arguments.length - 1];
          args = arguments.length >= 5 ? Array.prototype.slice.call(arguments, 3, -1) : [];
        } else {
          namedValues = {};
          args = arguments.length >= 4 ? Array.prototype.slice.call(arguments, 3) : [];
        }
        if (typeof singular === "object") {
          if (typeof singular.locale === "string" && typeof singular.singular === "string" && typeof singular.plural === "string") {
            targetLocale = singular.locale;
            msg = translate(singular.locale, singular.singular, singular.plural);
          }
          args.unshift(count);
          if (typeof plural === "number" || Number(plural) + "" === plural) {
            count = plural;
          }
          if (typeof singular.count === "number" || typeof singular.count === "string") {
            count = singular.count;
            args.unshift(plural);
          }
        } else {
          if (typeof plural === "number" || Number(plural) + "" === plural) {
            count = plural;
            plural = singular;
            args.unshift(count);
            args.unshift(plural);
          }
          msg = translate(getLocaleFromObject(this), singular, plural);
          targetLocale = getLocaleFromObject(this);
        }
        if (count === null)
          count = namedValues.count;
        count = Number(count);
        if (typeof msg === "object") {
          let p;
          if (PluralsForLocale[targetLocale]) {
            p = PluralsForLocale[targetLocale];
          } else {
            const lc = targetLocale.toLowerCase().split(/[_-\s]+/).filter((el2) => el2);
            p = MakePlural[lc[0] || targetLocale];
            PluralsForLocale[targetLocale] = p;
          }
          msg = msg[p(count)] || msg.other;
        }
        return postProcess(msg, namedValues, args, count);
      };
      i18n2.setLocale = function i18nSetLocale(object, locale, skipImplicitObjects) {
        if (Array.isArray(object) && typeof locale === "string") {
          for (let i = object.length - 1; i >= 0; i--) {
            i18n2.setLocale(object[i], locale, true);
          }
          return i18n2.getLocale(object[0]);
        }
        let targetObject = object;
        let targetLocale = locale;
        if (locale === void 0 && typeof object === "string") {
          targetObject = this;
          targetLocale = object;
        }
        if (!locales[targetLocale]) {
          targetLocale = getFallback(targetLocale, fallbacks) || targetLocale;
        }
        targetObject.locale = locales[targetLocale] ? targetLocale : defaultLocale;
        if (typeof register === "object") {
          if (Array.isArray(register) && !skipImplicitObjects) {
            register.forEach((r) => {
              r.locale = targetObject.locale;
            });
          } else {
            register.locale = targetObject.locale;
          }
        }
        if (targetObject.res && !skipImplicitObjects) {
          if (targetObject.res.locals) {
            i18n2.setLocale(targetObject.res, targetObject.locale, true);
            i18n2.setLocale(targetObject.res.locals, targetObject.locale, true);
          } else {
            i18n2.setLocale(targetObject.res, targetObject.locale);
          }
        }
        if (targetObject.locals && !skipImplicitObjects) {
          if (targetObject.locals.res) {
            i18n2.setLocale(targetObject.locals, targetObject.locale, true);
            i18n2.setLocale(targetObject.locals.res, targetObject.locale, true);
          } else {
            i18n2.setLocale(targetObject.locals, targetObject.locale);
          }
        }
        return i18n2.getLocale(targetObject);
      };
      i18n2.getLocale = function i18nGetLocale(request) {
        if (request && request.locale) {
          return request.locale;
        }
        return this.locale || defaultLocale;
      };
      i18n2.getCatalog = function i18nGetCatalog(object, locale) {
        let targetLocale;
        if (typeof object === "object" && typeof object.locale === "string" && locale === void 0) {
          targetLocale = object.locale;
        }
        if (!targetLocale && typeof object === "object" && typeof locale === "string") {
          targetLocale = locale;
        }
        if (!targetLocale && locale === void 0 && typeof object === "string") {
          targetLocale = object;
        }
        if (!targetLocale && object === void 0 && locale === void 0 && typeof this.locale === "string") {
          if (register && register.global) {
            targetLocale = "";
          } else {
            targetLocale = this.locale;
          }
        }
        if (targetLocale === void 0 || targetLocale === "") {
          return locales;
        }
        if (!locales[targetLocale]) {
          targetLocale = getFallback(targetLocale, fallbacks) || targetLocale;
        }
        if (locales[targetLocale]) {
          return locales[targetLocale];
        } else {
          logWarn('No catalog found for "' + targetLocale + '"');
          return false;
        }
      };
      i18n2.getLocales = function i18nGetLocales() {
        return Object.keys(locales);
      };
      i18n2.addLocale = function i18nAddLocale(locale) {
        read(locale);
      };
      i18n2.removeLocale = function i18nRemoveLocale(locale) {
        delete locales[locale];
      };
      const postProcess = (msg, namedValues, args, count) => {
        if (/\|/.test(msg)) {
          msg = parsePluralInterval(msg, count);
        }
        if (typeof count === "number") {
          msg = printf(msg, Number(count));
        }
        if (!mustacheConfig.disable && mustacheRegex.test(msg)) {
          msg = Mustache.render(msg, namedValues, {}, mustacheConfig.tags);
        }
        if (/%/.test(msg) && args && args.length > 0) {
          msg = printf(msg, ...args);
        }
        return msg;
      };
      const argsEndWithNamedObject = (args) => args.length > 1 && args[args.length - 1] !== null && typeof args[args.length - 1] === "object";
      const parseArgv = (args) => {
        let namedValues, returnArgs;
        if (argsEndWithNamedObject(args)) {
          namedValues = args[args.length - 1];
          returnArgs = Array.prototype.slice.call(args, 1, -1);
        } else {
          namedValues = {};
          returnArgs = args.length >= 2 ? Array.prototype.slice.call(args, 1) : [];
        }
        return [namedValues, returnArgs];
      };
      const applyAPItoObject = (object) => {
        let alreadySetted = true;
        for (const method in api) {
          if (Object.prototype.hasOwnProperty.call(api, method)) {
            const alias = api[method];
            if (!object[alias]) {
              alreadySetted = false;
              object[alias] = i18n2[method].bind(object);
            }
          }
        }
        if (!object.locale) {
          object.locale = defaultLocale;
        }
        if (alreadySetted) {
          return;
        }
        if (object.res) {
          applyAPItoObject(object.res);
        }
        if (object.locals) {
          applyAPItoObject(object.locals);
        }
      };
      const guessLocales = (directory2) => {
        const entries = fs.readdirSync(directory2);
        const localesFound = [];
        for (let i = entries.length - 1; i >= 0; i--) {
          if (entries[i].match(/^\./))
            continue;
          const localeFromFile = guessLocaleFromFile(entries[i]);
          if (localeFromFile)
            localesFound.push(localeFromFile);
        }
        return localesFound.sort();
      };
      const guessLocaleFromFile = (filename) => {
        const extensionRegex = new RegExp(extension + "$", "g");
        const prefixRegex = new RegExp("^" + prefix, "g");
        if (!filename)
          return false;
        if (prefix && !filename.match(prefixRegex))
          return false;
        if (extension && !filename.match(extensionRegex))
          return false;
        return filename.replace(prefix, "").replace(extensionRegex, "");
      };
      const extractQueryLanguage = (queryLanguage) => {
        if (Array.isArray(queryLanguage)) {
          return queryLanguage.find((lang) => lang !== "" && lang);
        }
        return typeof queryLanguage === "string" && queryLanguage;
      };
      const guessLanguage = (request) => {
        if (typeof request === "object") {
          const languageHeader = request.headers ? request.headers[languageHeaderName] : void 0;
          const languages = [];
          const regions = [];
          request.languages = [defaultLocale];
          request.regions = [defaultLocale];
          request.language = defaultLocale;
          request.region = defaultLocale;
          if (queryParameter && request.url) {
            const urlAsString = typeof request.url === "string" ? request.url : request.url.toString();
            const urlObj = url.parse(urlAsString, true);
            const languageQueryParameter = urlObj.query[queryParameter];
            if (languageQueryParameter) {
              let queryLanguage = extractQueryLanguage(languageQueryParameter);
              if (queryLanguage) {
                logDebug("Overriding locale from query: " + queryLanguage);
                if (preserveLegacyCase) {
                  queryLanguage = queryLanguage.toLowerCase();
                }
                return i18n2.setLocale(request, queryLanguage);
              }
            }
          }
          if (cookiename && request.cookies && request.cookies[cookiename]) {
            request.language = request.cookies[cookiename];
            return i18n2.setLocale(request, request.language);
          }
          if (languageHeader) {
            const acceptedLanguages = getAcceptedLanguagesFromHeader(languageHeader);
            let match;
            let fallbackMatch;
            let fallback;
            for (let i = 0; i < acceptedLanguages.length; i++) {
              const lang = acceptedLanguages[i];
              const lr = lang.split("-", 2);
              const parentLang = lr[0];
              const region = lr[1];
              const fallbackLang = getFallback(lang, fallbacks);
              if (fallbackLang) {
                fallback = fallbackLang;
                const acceptedLanguageIndex = acceptedLanguages.indexOf(lang);
                const fallbackIndex = acceptedLanguages.indexOf(fallback);
                if (fallbackIndex > -1) {
                  acceptedLanguages.splice(fallbackIndex, 1);
                }
                acceptedLanguages.splice(acceptedLanguageIndex + 1, 0, fallback);
              }
              const fallbackParentLang = getFallback(parentLang, fallbacks);
              if (fallbackParentLang) {
                fallback = fallbackParentLang;
                if (acceptedLanguages.indexOf(fallback) < 0) {
                  acceptedLanguages.push(fallback);
                }
              }
              if (languages.indexOf(parentLang) < 0) {
                languages.push(parentLang.toLowerCase());
              }
              if (region) {
                regions.push(region.toLowerCase());
              }
              if (!match && locales[lang]) {
                match = lang;
                break;
              }
              if (!fallbackMatch && locales[parentLang]) {
                fallbackMatch = parentLang;
              }
            }
            request.language = match || fallbackMatch || request.language;
            request.region = regions[0] || request.region;
            return i18n2.setLocale(request, request.language);
          }
        }
        return i18n2.setLocale(request, defaultLocale);
      };
      const getAcceptedLanguagesFromHeader = (header) => {
        const languages = header.split(",");
        const preferences = {};
        return languages.map((item) => {
          const preferenceParts = item.trim().split(";q=");
          if (preferenceParts.length < 2) {
            preferenceParts[1] = 1;
          } else {
            const quality = parseFloat(preferenceParts[1]);
            preferenceParts[1] = quality || 0;
          }
          preferences[preferenceParts[0]] = preferenceParts[1];
          return preferenceParts[0];
        }).filter((lang) => preferences[lang] > 0).sort((a2, b2) => preferences[b2] - preferences[a2]);
      };
      const getLocaleFromObject = (obj) => {
        let locale;
        if (obj && obj.scope) {
          locale = obj.scope.locale;
        }
        if (obj && obj.locale) {
          locale = obj.locale;
        }
        return locale;
      };
      const parsePluralInterval = (phrase, count) => {
        let returnPhrase = phrase;
        const phrases = phrase.split(/\|/);
        let intervalRuleExists = false;
        phrases.some((p) => {
          const matches = p.match(/^\s*([()[\]]+[\d,]+[()[\]]+)?\s*(.*)$/);
          if (matches != null && matches[1]) {
            intervalRuleExists = true;
            if (matchInterval(count, matches[1]) === true) {
              returnPhrase = matches[2];
              return true;
            }
          } else {
            if (intervalRuleExists) {
              returnPhrase = p;
            }
          }
          return false;
        });
        return returnPhrase;
      };
      const matchInterval = (number, interval) => {
        interval = parseInterval(interval);
        if (interval && typeof number === "number") {
          if (interval.from.value === number) {
            return interval.from.included;
          }
          if (interval.to.value === number) {
            return interval.to.included;
          }
          return Math.min(interval.from.value, number) === interval.from.value && Math.max(interval.to.value, number) === interval.to.value;
        }
        return false;
      };
      const translate = (locale, singular, plural, skipSyncToAllFiles) => {
        if (!skipSyncToAllFiles && syncFiles) {
          syncToAllFiles(singular, plural);
        }
        if (locale === void 0) {
          logWarn(
            "WARN: No locale found - check the context of the call to __(). Using " + defaultLocale + " as current locale"
          );
          locale = defaultLocale;
        }
        if (!locales[locale]) {
          locale = getFallback(locale, fallbacks) || locale;
        }
        if (!locales[locale]) {
          read(locale);
        }
        if (!locales[locale]) {
          logWarn(
            "WARN: Locale " + locale + " couldn't be read - check the context of the call to $__. Using " + defaultLocale + " (default) as current locale"
          );
          locale = defaultLocale;
          read(locale);
        }
        let defaultSingular = singular;
        let defaultPlural = plural;
        if (objectNotation) {
          let indexOfColon = singular.indexOf(":");
          if (indexOfColon > 0) {
            defaultSingular = singular.substring(indexOfColon + 1);
            singular = singular.substring(0, indexOfColon);
          }
          if (plural && typeof plural !== "number") {
            indexOfColon = plural.indexOf(":");
            if (indexOfColon > 0) {
              defaultPlural = plural.substring(indexOfColon + 1);
              plural = plural.substring(0, indexOfColon);
            }
          }
        }
        const accessor = localeAccessor(locale, singular);
        const mutator = localeMutator(locale, singular);
        if (plural) {
          if (accessor() == null) {
            if (retryInDefaultLocale && locale !== defaultLocale) {
              logDebug(
                "Missing " + singular + " in " + locale + " retrying in " + defaultLocale
              );
              mutator(translate(defaultLocale, singular, plural, true));
            } else {
              mutator({
                one: defaultSingular || singular,
                other: defaultPlural || plural
              });
            }
            write(locale);
          }
        }
        if (accessor() == null) {
          if (retryInDefaultLocale && locale !== defaultLocale) {
            logDebug(
              "Missing " + singular + " in " + locale + " retrying in " + defaultLocale
            );
            mutator(translate(defaultLocale, singular, plural, true));
          } else {
            mutator(defaultSingular || singular);
          }
          write(locale);
        }
        return accessor();
      };
      const syncToAllFiles = (singular, plural) => {
        for (const l in locales) {
          translate(l, singular, plural, true);
        }
      };
      const localeAccessor = (locale, singular, allowDelayedTraversal) => {
        if (!locales[locale])
          return Function.prototype;
        const indexOfDot = objectNotation && singular.lastIndexOf(objectNotation);
        if (objectNotation && indexOfDot > 0 && indexOfDot < singular.length - 1) {
          if (typeof allowDelayedTraversal === "undefined")
            allowDelayedTraversal = true;
          let accessor = null;
          const nullAccessor = () => null;
          let reTraverse = false;
          singular.split(objectNotation).reduce((object, index) => {
            accessor = nullAccessor;
            if (object === null || !Object.prototype.hasOwnProperty.call(object, index)) {
              reTraverse = allowDelayedTraversal;
              return null;
            }
            accessor = () => object[index];
            return object[index];
          }, locales[locale]);
          return () => (
            // If we need to re-traverse (because we didn't find our target term)
            // traverse again and return the new result (but don't allow further iterations)
            // or return the previously found accessor if it was already valid.
            reTraverse ? localeAccessor(locale, singular, false)() : accessor()
          );
        } else {
          return () => locales[locale][singular];
        }
      };
      const localeMutator = function(locale, singular, allowBranching) {
        if (!locales[locale])
          return Function.prototype;
        const indexOfDot = objectNotation && singular.lastIndexOf(objectNotation);
        if (objectNotation && indexOfDot > 0 && indexOfDot < singular.length - 1) {
          if (typeof allowBranching === "undefined")
            allowBranching = false;
          let accessor = null;
          const nullAccessor = () => null;
          let fixObject = () => ({});
          let reTraverse = false;
          singular.split(objectNotation).reduce((object, index) => {
            accessor = nullAccessor;
            if (object === null || !Object.prototype.hasOwnProperty.call(object, index)) {
              if (allowBranching) {
                if (object === null || typeof object !== "object") {
                  object = fixObject();
                }
                object[index] = {};
              } else {
                reTraverse = true;
                return null;
              }
            }
            accessor = (value) => {
              object[index] = value;
              return value;
            };
            fixObject = () => {
              object[index] = {};
              return object[index];
            };
            return object[index];
          }, locales[locale]);
          return (value) => {
            value = missingKeyFn(locale, value);
            return reTraverse ? localeMutator(locale, singular, true)(value) : accessor(value);
          };
        } else {
          return (value) => {
            value = missingKeyFn(locale, value);
            locales[locale][singular] = value;
            return value;
          };
        }
      };
      const read = (locale) => {
        let localeFile = {};
        const file = getStorageFilePath(locale);
        try {
          logDebug("read " + file + " for locale: " + locale);
          localeFile = fs.readFileSync(file, "utf-8");
          try {
            locales[locale] = parser.parse(localeFile);
          } catch (parseError) {
            logError(
              "unable to parse locales from file (maybe " + file + " is empty or invalid json?): ",
              parseError
            );
          }
        } catch (readError) {
          if (fs.existsSync(file)) {
            logDebug(
              "backing up invalid locale " + locale + " to " + file + ".invalid"
            );
            fs.renameSync(file, file + ".invalid");
          }
          logDebug("initializing " + file);
          write(locale);
        }
      };
      const write = (locale) => {
        let stats, target, tmp;
        if (!updateFiles) {
          return;
        }
        try {
          stats = fs.lstatSync(directory);
        } catch (e2) {
          logDebug("creating locales dir in: " + directory);
          try {
            fs.mkdirSync(directory, directoryPermissions);
          } catch (e3) {
            if (e3.code !== "EEXIST")
              throw e3;
          }
        }
        if (!locales[locale]) {
          locales[locale] = {};
        }
        try {
          target = getStorageFilePath(locale);
          tmp = target + ".tmp";
          fs.writeFileSync(
            tmp,
            parser.stringify(locales[locale], null, indent),
            "utf8"
          );
          stats = fs.statSync(tmp);
          if (stats.isFile()) {
            fs.renameSync(tmp, target);
          } else {
            logError(
              "unable to write locales to file (either " + tmp + " or " + target + " are not writeable?): "
            );
          }
        } catch (e2) {
          logError(
            "unexpected error writing files (either " + tmp + " or " + target + " are not writeable?): ",
            e2
          );
        }
      };
      const getStorageFilePath = (locale) => {
        const ext = extension || ".json";
        const filepath = path.normalize(directory + pathsep + prefix + locale + ext);
        const filepathJS = path.normalize(
          directory + pathsep + prefix + locale + ".js"
        );
        try {
          if (fs.statSync(filepathJS)) {
            logDebug("using existing file " + filepathJS);
            extension = ".js";
            return filepathJS;
          }
        } catch (e2) {
          logDebug("will use " + filepath);
        }
        return filepath;
      };
      const getFallback = (targetLocale, fallbacks2) => {
        fallbacks2 = fallbacks2 || {};
        if (fallbacks2[targetLocale])
          return fallbacks2[targetLocale];
        let fallBackLocale = null;
        for (const key in fallbacks2) {
          if (targetLocale.match(new RegExp("^" + key.replace("*", ".*") + "$"))) {
            fallBackLocale = fallbacks2[key];
            break;
          }
        }
        return fallBackLocale;
      };
      const logDebug = (msg) => {
        logDebugFn(msg);
      };
      const logWarn = (msg) => {
        logWarnFn(msg);
      };
      const logError = (msg) => {
        logErrorFn(msg);
      };
      const missingKey = (locale, value) => {
        return value;
      };
      if (_OPTS)
        i18n2.configure(_OPTS);
      return i18n2;
    };
    module.exports = i18n;
  }
});

// node_modules/i18n/index.js
var require_i18n2 = __commonJS({
  "node_modules/i18n/index.js"(exports, module) {
    var i18n = require_i18n();
    module.exports = i18n();
    module.exports.I18n = i18n;
  }
});
export default require_i18n2();
/*! Bundled license information:

mustache/mustache.js:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)

i18n/i18n.js:
  (**
   * @author      Created by Marcus Spiegel <spiegel@uscreen.de> on 2011-03-25.
   * @link        https://github.com/mashpie/i18n-node
   * @license     http://opensource.org/licenses/MIT
   *)
*/
//# sourceMappingURL=i18n.js.map
